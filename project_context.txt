Below is the entire codebase context. Please analyze it based on the user's request.

='='=' File: ./README_CN.md '='='='
```
# Photon-Commerce

[**ğŸ‡ºğŸ‡¸ English**](./README.md) | [**ğŸ‡¨ğŸ‡³ ä¸­æ–‡æ–‡æ¡£**](./README_CN.md)

![Build Status](https://img.shields.io/badge/build-passing-brightgreen)
![C++ Version](https://img.shields.io/badge/C++-23-blue)
![Architecture](https://img.shields.io/badge/Architecture-Microservices-orange)
![Communication](https://img.shields.io/badge/gRPC-Asynchronous-red)
![Gateway](https://img.shields.io/badge/Envoy-Proxy-purple)
![License](https://img.shields.io/badge/License-MIT-green.svg)

**Photon-Commerce** æ˜¯ä¸€ä¸ªåŸºäº **C++23** å’Œ **gRPC** æ„å»ºçš„é«˜æ€§èƒ½ã€äº‘åŸç”Ÿåˆ†å¸ƒå¼ç”µå•†å¹³å°å¼•æ“ã€‚

æœ¬é¡¹ç›®æ—¨åœ¨æ¢ç´¢æè‡´çš„åç«¯æ€§èƒ½ä¸æ¶æ„è®¾è®¡ï¼Œèåˆäº† **åç¨‹**ã€**æ— é”ç¼–ç¨‹**ã€**é¢†åŸŸé©±åŠ¨è®¾è®¡** ä»¥åŠ **Saga åˆ†å¸ƒå¼äº‹åŠ¡** ç­‰å…ˆè¿›æŠ€æœ¯ç†å¿µã€‚

---

## ğŸš€ æ ¸å¿ƒç‰¹æ€§

### âš¡ï¸ï¸ æè‡´æ€§èƒ½ä¸å¼‚æ­¥æ¶æ„
* **å…¨é“¾è·¯å¼‚æ­¥åŒ–**ï¼šåŸºäº gRPC å¼‚æ­¥æ¨¡å‹ä¸ C++20 åç¨‹ï¼Œå®ç°äº†é«˜å¹¶å‘ä¸‹çš„ä½å»¶è¿Ÿå¤„ç†ï¼Œæ‹’ç» I/O é˜»å¡ã€‚
* **CallData çŠ¶æ€æœºå¼•æ“**ï¼šè®¾è®¡äº†åŸºäº 3 å±‚ç»§æ‰¿ä¸æ¨¡æ¿å…ƒç¼–ç¨‹çš„ `CallData` å°è£…ï¼Œç»“åˆ **CRTP (å¥‡å¼‚é€’å½’æ¨¡æ¿æ¨¡å¼)**ï¼Œå®ç°äº†ç¼–è¯‘æœŸå¤šæ€ä¸å†…å­˜æè‡´ä¼˜åŒ–ã€‚
* **å¯¹è±¡æ± åŒ–æŠ€æœ¯**ï¼šå®ç°äº†é€šç”¨çš„ `Manager` å¯¹è±¡æ± æ¨¡æ¿ï¼Œå¤ç”¨ `CallData` å¯¹è±¡ï¼Œå¤§å¹…å‡å°‘å†…å­˜åˆ†é… (new/delete) å¼€é”€ã€‚
* **é›¶å¼€é”€æŠ½è±¡**ï¼šåˆ©ç”¨ `Boost.DI` å®ç°ä¾èµ–æ³¨å…¥ä¸æ§åˆ¶åè½¬ï¼Œåœ¨ä¿è¯ä»£ç è§£è€¦çš„åŒæ—¶ç»´æŒè¿è¡Œæ—¶æ€§èƒ½ã€‚

### ğŸ§© åˆ†å¸ƒå¼ä¸å¾®æœåŠ¡æ²»ç†
* **API ç½‘å…³é›†æˆ**ï¼šé›†æˆ **Envoy** ä½œä¸ºæµé‡å…¥å£ï¼Œè‡ªåŠ¨å®ç° RESTful API åˆ° gRPC çš„åè®®è½¬æ¢ã€‚
* **æ•°æ®ä¸€è‡´æ€§**ï¼šé‡‡ç”¨ **Saga æ¨¡å¼** è§£å†³å¾®æœåŠ¡é—´çš„æ•°æ®ä¸€è‡´æ€§é—®é¢˜ï¼Œä¿éšœåˆ†å¸ƒå¼äº‹åŠ¡çš„æœ€ç»ˆä¸€è‡´æ€§ã€‚
* **é¢†åŸŸé©±åŠ¨è®¾è®¡**ï¼šé‡‡ç”¨ **å……è¡€æ¨¡å‹** è®¾è®¡ä¸šåŠ¡é€»è¾‘ï¼Œå®ç°æ¸…æ™°çš„æ¶æ„åˆ†å±‚ã€‚
* **å¼‚æ­¥æ•°æ®åº“äº¤äº’**ï¼šåŸºäº `libpq` å°è£…äº†åç¨‹åŒ–çš„å¼‚æ­¥æ•°æ®åº“è¿æ¥æ± ï¼Œé«˜æ•ˆå¤„ç†æŒä¹…åŒ–éœ€æ±‚ã€‚

---

## ğŸ“ ç³»ç»Ÿæ¶æ„ä¸æ ¸å¿ƒè®¾è®¡

### 1. æ€»ä½“æ¶æ„å›¾
![System Architecture](docs/images/zh/system_architecture_zh.png)

### 2. CallData å¼‚æ­¥çŠ¶æ€æœºè®¾è®¡
![CallData Design](docs/images/zh/grpc_async_workflow_zh.png)

---

## âš™ï¸ æŠ€æœ¯æ ˆæ¦‚è§ˆ

| ç»´åº¦         | é€‰å‹æ–¹æ¡ˆ                 | æ ¸å¿ƒè€ƒé‡                        |
|:-----------|:---------------------|:----------------------------|
| **å¼€å‘è¯­è¨€**   | **C++23**            | Concepts, Coroutines, Boost |
| **é€šä¿¡åè®®**   | **gRPC & Protobuf**  | é«˜æ€§èƒ½ RPCï¼Œå¼‚æ­¥æµå¼å¤„ç†              |
| **API ç½‘å…³** | **Envoy Proxy**      | æµé‡æ²»ç†ï¼ŒREST è½¬ gRPC            |
| **æ•°æ®å­˜å‚¨**   | **PostgreSQL**       | å…³ç³»å‹æ•°æ®æŒä¹…åŒ–                    |
| **ç¼“å­˜ç³»ç»Ÿ**   | **Redis**            | çƒ­ç‚¹æ•°æ®ç¼“å­˜ä¸çŠ¶æ€ç®¡ç†                 |
| **ä¾èµ–ç®¡ç†**   | **vcpkg & CMake**    | ç°ä»£ C++ åŒ…ç®¡ç†ä¸æ„å»ºç³»ç»Ÿ             |
| **å®¹å™¨åŒ–**    | **Docker**           | æ ‡å‡†åŒ–å¼€å‘ä¸è¿è¡Œç¯å¢ƒ                  |
| **éƒ¨ç½²æ¶æ„**   | **Kubernetes (K8s)** | æœåŠ¡ç¼–æ’ä¸è‡ªåŠ¨æ‰©ç¼©å®¹                  |

### å…³é”®ä¾èµ–åº“
| åº“åç§°          | ç”¨é€”              | è¯´æ˜                                                 |
|:-------------|:----------------|:---------------------------------------------------|
| `googleapis` | API Transcoding | æä¾› HTTP/JSON åˆ° gRPC çš„æ˜ å°„æ”¯æŒ                          |
| `Boost`      | æ ¸å¿ƒç»„ä»¶            | åŒ…å« `Asio` (ç½‘ç»œ/åç¨‹è°ƒåº¦) åŠ `Boost.Redis` (å¼‚æ­¥ Redis å®¢æˆ·ç«¯) |
| `Boost.DI`   | ä¾èµ–æ³¨å…¥            | ç°ä»£ C++ ç¼–è¯‘æœŸä¾èµ–æ³¨å…¥åº“ (é›¶å¼€é”€æ§åˆ¶åè½¬)                          |
| `libpq`      | æ•°æ®åº“é©±åŠ¨           | PostgreSQL åº•å±‚ C æ¥å£ï¼Œå·²å°è£…ä¸ºå¼‚æ­¥                          |
| `moodycamel` | å¹¶å‘æ•°æ®ç»“æ„          | é«˜æ€§èƒ½æ— é”é˜Ÿåˆ— (ConcurrentQueue)                          |
| `spdlog`     | æ—¥å¿—ç³»ç»Ÿ            | æé€Ÿ C++ æ—¥å¿—åº“                                         |
| `cryptopp`   | å®‰å…¨åŠ å¯†            | å¯†ç å“ˆå¸Œä¸åŠ è§£å¯†                                           |
| `jwt-cpp`    | èº«ä»½è®¤è¯            | JSON Web Token å¤„ç†                                  |
| `uuid_v7`    | ID ç”Ÿæˆ           | åˆ†å¸ƒå¼å”¯ä¸€ ID ç®¡ç†                                        |
| `yaml-cpp`   | é…ç½®ç®¡ç†            | YAML é…ç½®æ–‡ä»¶è§£æ                                        |
---

## â–¶ï¸ å¿«é€Ÿå¼€å§‹

> æœ¬æŒ‡å—ç”¨äºå¸®åŠ©åœ¨æœ¬åœ°å¿«é€Ÿæ­å»ºå¼€å‘ç¯å¢ƒã€‚

### 1. è·å–æºç 
**æ³¨æ„**ï¼šåŠ¡å¿…ä½¿ç”¨ `--recursive` å‚æ•°ä»¥åŒ…å«æ‰€æœ‰å­æ¨¡å—ã€‚

```bash
# é¦–æ¬¡å…‹éš†
git clone --recursive git@github.com:seaStarLxy/ECommerceSystem-Microservices.git

# è‹¥å·²å…‹éš†ä½†ç¼ºå°‘å­æ¨¡å—
git submodule update --init --recursive

### 2. ç¯å¢ƒä¾èµ–å®‰è£…
# æœ¬é¡¹ç›®æ¨èä½¿ç”¨ Ubuntu 24.04 ç¯å¢ƒã€‚

#### åŸºç¡€å·¥å…·é“¾
```bash
sudo apt update
sudo apt install -y build-essential pkg-config ninja-build zip unzip tar libssl-dev curl gdb bison flex autoconf automake libtool git net-tools
```

#### C++ ä¾èµ–ç®¡ç† (vcpkg)
ä½¿ç”¨ vcpkg ç®¡ç†æ‰€æœ‰ C++ ç¬¬ä¸‰æ–¹åº“ã€‚

```bash
git clone https://github.com/microsoft/vcpkg.git ~/vcpkg
~/vcpkg/bootstrap-vcpkg.sh

# é…ç½®ç¯å¢ƒå˜é‡
echo "" >> ~/.bashrc
echo "# vcpkg config" >> ~/.bashrc
echo "export VCPKG_ROOT=~/vcpkg" >> ~/.bashrc
echo 'export PATH=$VCPKG_ROOT:$PATH' >> ~/.bashrc
source ~/.bashrc
```

### 3. ç¼–è¯‘ä¸æ„å»º
é…ç½® CMake æ—¶éœ€æŒ‡å®š vcpkg å·¥å…·é“¾ï¼š

```bash
mkdir build && cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE=~/vcpkg/scripts/buildsystems/vcpkg.cmake
cmake --build .
```

### 4. æœåŠ¡ç½‘å…³éƒ¨ç½² (Envoy)
Envoy è´Ÿè´£å°†å‰ç«¯ HTTP è¯·æ±‚è½¬å‘ä¸ºåç«¯ gRPC è°ƒç”¨ã€‚

```bash
# 1. å®‰è£… Envoy (Debian/Ubuntu)
wget -O- [https://apt.envoyproxy.io/signing.key](https://apt.envoyproxy.io/signing.key) | sudo gpg --dearmor -o /etc/apt/keyrings/envoy-keyring.gpg
echo "deb [signed-by=/etc/apt/keyrings/envoy-keyring.gpg] [https://apt.envoyproxy.io](https://apt.envoyproxy.io) bookworm main" | sudo tee /etc/apt/sources.list.d/envoy.list
sudo apt update && sudo apt install envoy

# æ£€æŸ¥å®‰è£…
envoy --version

# 2. ç”Ÿæˆ proto.pb (ä¾› Envoy è¿›è¡Œåè®®è½¬æ¢ä½¿ç”¨)
# æ³¨æ„ï¼šè·¯å¾„éœ€æ ¹æ®å®é™…ç¯å¢ƒè°ƒæ•´
# å‡è®¾å½“å‰ä½äºé¡¹ç›®æ ¹ç›®å½•
./vcpkg_installed/x64-linux/tools/protobuf/protoc \
  -I ./IDL \
  -I ./third_party/googleapis \
  --include_imports \
  --descriptor_set_out=./apiGateway/proto.pb \
  ./IDL/UserService/v1/user_service.proto

# 3. å¯åŠ¨ Envoy
envoy -c ./apiGateway/envoy.yaml -l info
```

### 5. åŸºç¡€ä¸­é—´ä»¶
è¯·ç¡®ä¿å·²å®‰è£…å¹¶å¯åŠ¨ä»¥ä¸‹æœåŠ¡ï¼š
1.  **PostgreSQL**: ç”¨äºæ•°æ®æŒä¹…åŒ–
2.  **Redis**: ç”¨äºçŠ¶æ€ç®¡ç†ä¸ç¼“å­˜
> æœ¬é¡¹ç›®ä½¿ç”¨äº‘åŸç”Ÿæ•°æ®åº“
---

## ğŸ§­ å¼€å‘è€…æŒ‡å—

ä¸ºä¿è¯ä»£ç è´¨é‡ä¸åä½œæ•ˆç‡ï¼Œé¡¹ç›®éµå¾ªä»¥ä¸‹è§„èŒƒã€‚

### ä»£ç å‘½åè§„èŒƒ
| ç±»å‹ | é£æ ¼ | ç¤ºä¾‹ |
|:---|:---|:---|
| **ç±»/ç»“æ„ä½“** | PascalCase | `UserSession`, `OrderManager` |
| **å‡½æ•°/æ–¹æ³•** | PascalCase | `GetUserInfo()`, `CalculatePrice()` |
| **æ–‡ä»¶/ç›®å½•** | snake_case | `user_service.h`, `async_logger.cpp` |
| **å˜é‡/å‚æ•°** | snake_case | `user_id`, `request_timeout` |
| **æˆå‘˜å˜é‡** | snake_case + `_` | `db_connection_`, `mutex_` |
| **å‘½åç©ºé—´** | snake_case | `photon_commerce` |

### Git å·¥ä½œæµ
æœ¬é¡¹ç›®é‡‡ç”¨ Feature Branch å·¥ä½œæµã€‚

1.  **åŒæ­¥ä¸»åˆ†æ”¯**: `git checkout main && git pull`
2.  **åˆ›å»ºåˆ†æ”¯**:
    * æ–°åŠŸèƒ½: `git checkout -b feature/your-feature-name`
    * ä¿®å¤ Bug: `git checkout -b bugfix/your-fix-name`
    * é‡æ„: `git checkout -b refactor/your-refactor-name`
    * æ›´æ–°æ–‡æ¡£: `git checkout -b docs/update-readme`
    * æ„å»º/é…ç½®: `git checkout -b chore/update-cmake`
3.  **æäº¤ä»£ç **:
    ```bash
    git add .
    git commit -s -m "feat: implement jwt authentication logic"
    ```
4.  **æ¨é€ä¸åˆå¹¶**:
    ```bash
    git push -u origin feature/your-feature-name
    # éšååœ¨ GitHub å‘èµ· Pull Request (PR) å¹¶ç­‰å¾… CI æ£€æŸ¥é€šè¿‡
    ```

---

## âš–ï¸ License

æœ¬é¡¹ç›®é‡‡ç”¨ [MIT License](./LICENSE) è®¸å¯è¯ã€‚
```

='='=' File: ./README.md '='='='
```
# Photon-Commerce

[**ğŸ‡¨ğŸ‡³ ä¸­æ–‡æ–‡æ¡£**](./README_CN.md) | [**ğŸ‡ºğŸ‡¸ English**](./README.md)

```

='='=' File: ./envBuild/v1/docker-compose.yml '='='='
```
name: ECommerceSystem
services:
  grpc-dev:
    image: grpc-dev:v2
    container_name: grpc-dev
    restart: unless-stopped
    ports:
      - "10022:22"
    volumes:
      - ..:/app
      - clion_cache:/root/.cache/JetBrains  # æŒä¹…åŒ– clion åç«¯ç¯å¢ƒ
    depends_on:
      - postgres-db
      - redis-cache
    networks:
      - grpc-net

  # Envoy ç½‘å…³æœåŠ¡
  envoy-gateway:
    image: envoyproxy/envoy:contrib-v1.34.9
    container_name: envoy-gateway
    restart: unless-stopped
    ports:
      - "8080:8080"
    volumes:
      - ../apiGateway/envoy.yaml:/etc/envoy/envoy.yaml
      - ../apiGateway/proto.pb:/etc/envoy/proto.pb
    networks:
      - grpc-net
    depends_on:
      - grpc-dev

  # Postgresql æŒä¹…åŒ–
  postgres-db:
    image: postgres:14-alpine
    container_name: postgres-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: lxy
      POSTGRES_PASSWORD: 1234
      POSTGRES_DB: ecommerce_db
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - grpc-net

  redis-cache:
    image: redis:7-alpine
    container_name: redis-cache
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - grpc-net

volumes:
  clion_cache:
  postgres-data:
  redis-data:

networks:
  grpc-net:
    driver: bridge
```

='='=' File: ./envBuild/v1/Readme.md '='='='
```

æ„å»ºå¼€å‘ç¯å¢ƒ
docker build -t grpc-dev:v1 .
docker build -t grpc-dev:v2 .

docker run -it --rm --name temp-test -v ..:/app grpc-dev:v2 bash

æ„å»ºè¿è¡Œç¯å¢ƒ
docker build -t customized-grpc:v1 .

docker-compose up -d

docker-compose down

> extra: 
curl
sudo apt install libboost-all-dev
> apt install libboost-coroutine-dev

> zip unzip tar
>

# grpc-dev-wsl
```shell
git
sudo apt install curl zip unzip tar build-essential 
```

```

='='=' File: ./envBuild/v2/Readme.md '='='='
```
# åŸºäº wsl å¼€å‘ç¯å¢ƒéƒ¨ç½²
```shell
# é¢å¤–å®‰è£…éƒ¨åˆ†
sudo apt install curl zip unzip tar build-essential gdb pkg-config bison flex autoconf
```

```shell
cd envBuild/v2
docker run -d \
  --name envoy-gateway-v2 \
  -p 8080:8080 \
  --restart unless-stopped \
  -v "$(pwd)/../../apiGateway/envoy.yaml":/etc/envoy/envoy.yaml \
  -v "$(pwd)/../../apiGateway/proto.pb":/etc/envoy/proto.pb \
  envoyproxy/envoy:contrib-v1.34.9
```


```

='='=' File: ./IDL/UserService/v1/user_service.proto '='='='
```
syntax = "proto3";

package user_service.proto.v1;

import "google/api/annotations.proto";


// 1. AuthService (è®¤è¯æœåŠ¡)
service AuthService {
  // å‘é€éªŒè¯ç 
  rpc SendCode(SendCodeRequest) returns (SendCodeResponse) {
    option (google.api.http) = {
      post: "/v1/auth/send_code"
      body: "*"
    };
  }

  // å¯†ç ç™»å½•
  rpc LoginByPassword(LoginByPasswordRequest) returns (LoginResponse) {
    option (google.api.http) = {
      post: "/v1/auth/login_by_password"
      body: "*"
    };
  }

  // éªŒè¯ç ç™»å½•
  rpc LoginByCode(LoginByCodeRequest) returns (LoginResponse) {
    option (google.api.http) = {
      post: "/v1/auth/login_by_code"
      body: "*"
    };
  }
}


// 2. UserService (ç”¨æˆ·æœåŠ¡)
service UserService {
  // ç”¨æˆ·æ³¨å†Œ (ä½¿ç”¨éªŒè¯ç )
  rpc Register(RegisterRequest) returns (RegisterResponse) {
    option (google.api.http) = {
      post: "/v1/users/register"
      body: "*"
    };
  }

  // è·å–ç”¨æˆ·ä¿¡æ¯
  rpc GetUserInfo(GetUserInfoRequest) returns (GetUserInfoResponse) {
    option (google.api.http) = {
      get: "/v1/users/{user_id}"
    };
  }

  // ä¿®æ”¹ç”¨æˆ·ä¿¡æ¯
  rpc UpdateUserInfo(UpdateUserInfoRequest) returns (UpdateUserInfoResponse) {
    option (google.api.http) = {
      put: "/v1/users/{user.user_id}" // (ä½¿ç”¨ PATCH è¯­ä¹‰)
      body: "user"
    };
  }
}

// æ¶ˆæ¯ä½“å®šä¹‰
// é€šç”¨å®ä½“
message CommonStatus {
  int32 code = 1;         // 0 ä»£è¡¨æˆåŠŸï¼Œé 0 ä»£è¡¨ä¸šåŠ¡å¤±è´¥ç  (ä¾‹å¦‚ 10001)
  string message = 2;     // é”™è¯¯ä¿¡æ¯æˆ–æˆåŠŸæç¤º
}

message User {
  string user_id = 1;
  string username = 2;
  string email = 3;
  string avatar_url = 4;
  string phone_number = 5;
}

// AuthService æ¶ˆæ¯ä½“
enum CodeUsage {
  UNKNOWN = 0;
  USER_REGISTER = 1;
  USER_LOGIN = 2;
  RESET_PASSWORD = 3;
}
message SendCodeRequest {
  string phone_number = 1;
  CodeUsage usage = 2;
}

message SendCodeResponse {
  CommonStatus status = 1;
}

message LoginByPasswordRequest {
  string username = 1;
  string password = 2;
}
message LoginByCodeRequest {
  string phone_number = 1;
  string code = 2;
}
message LoginResponse {
  CommonStatus status = 1;
  string token = 2;
  User user = 3;
}

// UserService æ¶ˆæ¯ä½“
message RegisterRequest {
  string username = 1;
  string password = 2;
  string phone_number = 3;
  string code = 4;
}
message RegisterResponse {
  CommonStatus status = 1;
  string user_id = 2;
}

message GetUserInfoRequest {
  string user_id = 1;
}
message GetUserInfoResponse {
  CommonStatus status = 1;
  User user = 2;
}

message UpdateUserInfoRequest {
  User user = 1;
}
message UpdateUserInfoResponse {
  CommonStatus status = 1;
}
```

='='=' File: ./UserService/main.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include <spdlog/spdlog.h>
#include "server/application.h"

using namespace user_service::server;
namespace di = boost::di;

void LogInit() {
    spdlog::set_level(spdlog::level::trace);
    spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%l] [thread %t] [%s:%# (%!)] %v");
}

int main() {
    LogInit();
    try {
        const Application app("config/config.yaml");
        app.Run();
    } catch (...) {
        return -1;
    }
    return 0;
}

```

='='=' File: ./UserService/CMakeLists.txt '='='='
```
cmake_minimum_required(VERSION 3.20)
project(UserService LANGUAGES CXX)

# æ³¨æ„åç¨‹éœ€è¦ C20 æ ‡å‡†ä»¥ä¸Š
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(gRPC REQUIRED)
message(STATUS "Found gRPC: ${gRPC_FOUND}")
find_package(PostgreSQL REQUIRED)
message(STATUS "Found PostgreSQL: ${PostgreSQL_FOUND}")
find_package(OpenSSL REQUIRED)
find_package(stduuid CONFIG REQUIRED)
find_package(jwt-cpp CONFIG REQUIRED)
find_package(cryptopp REQUIRED)
find_package(yaml-cpp CONFIG REQUIRED)
find_package(spdlog CONFIG REQUIRED)
add_compile_definitions(SPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_TRACE)


# è‡ªå®šä¹‰ IDL ç›®å½•
set(MY_IDL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../IDL")
# google IDL ç›®å½•
set(GOOGLEAPIS_PROTOS_DIR "../third_party/googleapis")
# æ”¶é›† è‡ªå®šä¹‰IDLå’Œå…¶ä¾èµ– google IDL ç›®å½•ä¸­çš„ .proto æ–‡ä»¶
set(PROTO_FILES
        "${MY_IDL_DIR}/UserService/v1/user_service.proto"
        "${GOOGLEAPIS_PROTOS_DIR}/google/api/annotations.proto"
        "${GOOGLEAPIS_PROTOS_DIR}/google/api/http.proto"
)
message(STATUS "Proto files: ${PROTO_FILES}")


# ç”Ÿæˆæ–‡ä»¶å­˜æ”¾ç›®å½•
set(PROTO_BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated")
file(MAKE_DIRECTORY ${PROTO_BINARY_DIR})
# æ³¨å†Œè‡ªå®šä¹‰ä¸´æ—¶åº“ç›®æ ‡
add_library(my_proto_lib OBJECT
        ${PROTO_FILES}
)
target_link_libraries(my_proto_lib PUBLIC protobuf::libprotobuf)
target_include_directories(my_proto_lib PUBLIC "$<BUILD_INTERFACE:${PROTO_BINARY_DIR}>")
# 1. ç”Ÿæˆ .pb.h å’Œ .pb.cc
# 2. æ·»åŠ åˆ° my_proto_lib ä¸´æ—¶åº“
protobuf_generate(
        TARGET my_proto_lib
        LANGUAGE cpp
        IMPORT_DIRS
        "${GOOGLEAPIS_PROTOS_DIR}"
        "${MY_IDL_DIR}"
        PROTOC_OUT_DIR "${PROTO_BINARY_DIR}"
        GENERATE_EXTENSIONS .pb.h .pb.cc
)
protobuf_generate(
        TARGET my_proto_lib
        LANGUAGE grpc
        IMPORT_DIRS
        "${GOOGLEAPIS_PROTOS_DIR}"
        "${MY_IDL_DIR}"
        PROTOC_OUT_DIR "${PROTO_BINARY_DIR}"
        GENERATE_EXTENSIONS .grpc.pb.h .grpc.pb.cc
        PLUGIN "protoc-gen-grpc=$<TARGET_FILE:gRPC::grpc_cpp_plugin>"
)


# æ”¶é›†æºæ–‡ä»¶
set(SERVER_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/server/user_service_server.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/server/application.cc"
)

set(ADAPTER_FILES
        #        v1
        #        "${CMAKE_CURRENT_SOURCE_DIR}/adapter/v1/src/register_call_data.cc"
        #         v2
        "${CMAKE_CURRENT_SOURCE_DIR}/adapter/v2/call_data_manager/src/register_call_data_manager.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/adapter/v2/call_data/src/register_call_data.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/adapter/v2/call_data_manager/src/send_code_call_data_manager.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/adapter/v2/call_data/src/send_code_call_data.cc"
)

set(SERVICE_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/service/src/auth_service.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/service/src/basic_user_service.cc"
)

set(DOMAIN_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/domain/user.cc"
)

set(INFRASTRUCTURE_FILES
        # domain_implement
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/domain_implement/src/verification_code_repository.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/domain_implement/src/user_repository.cc"
        # persistence
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/persistence/postgresql/src/pq_connection.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/persistence/postgresql/src/async_connection_pool.cc"
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/persistence/dao/user_dao.cc"
        # state_storage
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/state_storage/redis_dao/redis_client.cc"
        # asio_thread_pool
        "${CMAKE_CURRENT_SOURCE_DIR}/infrastructure/asio_thread_pool/asio_thread_pool.cc"
)

set(UTILS_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/utils/src/verification_code_generator.cc"
)

set(CONFIG_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/config/app_config.cc"
)

set(BUILTIN_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/builtin_impl/builtin_impl.cc"
)

# æ·»åŠ ä¸»ç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶
add_executable(UserServiceServer
        main.cc
        ${SERVER_FILES}
        ${ADAPTER_FILES}
        ${SERVICE_FILES}
        ${DOMAIN_FILES}
        ${INFRASTRUCTURE_FILES}
        ${UTILS_FILES}
        ${CONFIG_FILES}
        ${BUILTIN_FILES}
)

# æ·»åŠ é¢„ç¼–è¯‘å¤´æ–‡ä»¶ PCH
target_precompile_headers(UserServiceServer PRIVATE
        # --- æ ‡å‡†åº“ ---
        <memory>
        <string>
        <vector>
        <future>

        # --- å·¨å‹ç¬¬ä¸‰æ–¹åº“ (åŠ é€Ÿç¼–è¯‘) ---
        <boost/di.hpp>
        <boost/asio.hpp>
        <spdlog/spdlog.h>
        <grpcpp/grpcpp.h>
        <jwt-cpp/jwt.h>
        <stduuid/uuid.h>
        <boost/redis.hpp>
)

# æ·»åŠ å¤´æ–‡ä»¶åŒ…å«ç›®å½•
target_include_directories(UserServiceServer PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
)

# é“¾æ¥ç›¸å…³åº“
target_link_libraries(UserServiceServer PUBLIC
        my_proto_lib        # é“¾æ¥è‡ªå·±ç”Ÿæˆçš„ proto ä»£ç åº“
        gRPC::grpc++
        OpenSSL::SSL
        OpenSSL::Crypto
        PostgreSQL::PostgreSQL
        cryptopp::cryptopp
        jwt-cpp::jwt-cpp
        spdlog::spdlog
        stduuid
        yaml-cpp::yaml-cpp
)

file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/config/config.yaml
        DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/config)
```

='='=' File: ./UserService/server/user_service_server.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "user_service_server.h"
#include <boost/asio/io_context.hpp>
#include <spdlog/spdlog.h>

#include "adapter/v2/call_data_manager/include/register_call_data_manager.h"
#include "adapter/v2/call_data/include/register_call_data.h"
#include "adapter/v2/call_data_manager/include/send_code_call_data_manager.h"
#include "adapter/v2/call_data/include/send_code_call_data.h"

// #include "adapter/v2/call_data/interface/call_data.hpp"

using namespace user_service::server;
using namespace user_service::adapter::v2;

UserServiceServer::UserServiceServer(const std::shared_ptr<service::IAuthService> &auth_service,
                                     const std::shared_ptr<service::IBasicUserService> &basic_service,
                                     const std::shared_ptr<boost::asio::io_context> &ioc) : ioc_(ioc),
    auth_business_service_(auth_service), basic_user_business_service_(basic_service) {
}

UserServiceServer::~UserServiceServer() = default;

void UserServiceServer::Run() {
    // å¯åŠ¨ gRPC æœåŠ¡å™¨
    std::string ipv4_address("0.0.0.0:50051");
    // std::string ipv6_address("[::]:50051");
    grpc::ServerBuilder builder;
    builder.AddListeningPort(ipv4_address, grpc::InsecureServerCredentials());
    // builder.AddListeningPort(ipv6_address, grpc::InsecureServerCredentials());
    builder.RegisterService(&auth_grpc_service_);
    builder.RegisterService(&basic_user_grpc_service_);
    cq_ = builder.AddCompletionQueue();
    server_ = builder.BuildAndStart();
    SPDLOG_DEBUG("Server listening on {}", ipv4_address);

    // åŸå§‹æ’­ç§æ³•
    // (new RegisterCallData(&service_, cq_.get(), *ioc_, basic_service_))->Init();
    SPDLOG_DEBUG("Seeded RegisterCallData.");
    RegisterCallDataManager register_manager = RegisterCallDataManager(100, &basic_user_grpc_service_, basic_user_business_service_.get(), ioc_, cq_.get());
    register_manager.Start();
    SendCodeCallDataManager send_code_manager = SendCodeCallDataManager(100, &auth_grpc_service_, auth_business_service_.get(), ioc_, cq_.get());
    send_code_manager.Start();


    // å¯åŠ¨ Worker çº¿ç¨‹æ± 
    unsigned num_workers = std::thread::hardware_concurrency();
    SPDLOG_DEBUG("Starting {} worker threads...", num_workers);
    worker_threads_.reserve(num_workers);
    for (int i = 0; i < num_workers; ++i) {
        worker_threads_.emplace_back(&UserServiceServer::HandleRpc, this);
    }
    SPDLOG_DEBUG("Worker threads startup finished");

    // é˜»å¡ä¸»çº¿ç¨‹
    server_->Wait();
}

void UserServiceServer::Shutdown() {
    server_->Shutdown();
    cq_->Shutdown();
    for (auto &t: worker_threads_) {
        t.join();
    }
}

void UserServiceServer::HandleRpc() const {
    void *tag; // tag å®é™…ä¸Šæ˜¯ ICallData*
    bool ok;

    // å¾ªç¯ï¼šé˜»å¡åœ°ä» CQ ä¸­å–äº‹ä»¶
    while (cq_->Next(&tag, &ok)) {
        if (!ok) {
            // CQ æ­£åœ¨å…³é—­
            break;
        }
        SPDLOG_DEBUG("Get one request");
        static_cast<ICallData*>(tag)->Proceed();
    }
}

```

='='=' File: ./UserService/server/application.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "server/application.h"
#include <spdlog/spdlog.h>
#include <boost/di.hpp>
#include <utility>
#include "server/user_service_server.h"

#include "service/include/auth_service.h"
#include "service/include/basic_user_service.h"

#include "infrastructure/asio_thread_pool/asio_thread_pool.h"
#include "infrastructure/state_storage/redis_dao/redis_client.h"
#include "infrastructure/persistence/postgresql/include/async_connection_pool.h"
#include "infrastructure/persistence/dao/user_dao.h"
#include "infrastructure/domain_implement/include/verification_code_repository.h"
#include "infrastructure/domain_implement/include/user_repository.h"

#include "utils/include/verification_code_generator.h"

#include "config/app_config.h"

using namespace user_service::infrastructure;
using namespace user_service::service;
using namespace user_service::server;
using namespace user_service::util;
using namespace user_service::domain;
using namespace user_service::config;

namespace di = boost::di;

Application::Application(std::string&& config_filepath): config_path_(std::move(config_filepath)),
    ioc_(std::make_shared<boost::asio::io_context>()) {

    SPDLOG_INFO("Application constructing...");

    // åŠ è½½é…ç½®
    const auto app_config = AppConfig(config_path_);
    const auto redis_config = app_config.GetRedisConfig();
    const auto db_pool_config = app_config.GetDBPoolConfig();

    /*
     * bind<T> è¦ä»€ä¹ˆï¼Œä¼ å…¥Tï¼Œå¯ä»¥è‡ªåŠ¨è§£ææ„é€ å‡½æ•°ä¸­çš„ T T* Tæ™ºèƒ½æŒ‡é’ˆç­‰ç­‰
     * to<U> ç»™ä»€ä¹ˆï¼Œä¼ å…¥çš„Uè‡³å°‘å¯ä»¥éšå¼è½¬æ¢æˆTã€‚çœç•¥toåˆ™ä»£è¡¨ç›´æ¥æ„é€ Tç±»å‹
     * in æ€ä¹ˆç»™
     */
    // æ³¨æ„è¿™é‡Œçš„diå†…éƒ¨ä¼šå¯¹ç±»å‹è§£æï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨å‰å‘å£°æ˜ï¼Œå¿…é¡»ä½¿ç”¨includeå¤´æ–‡ä»¶ï¼ˆç°åœ¨åœ¨æºæ–‡ä»¶å…¶å®ä¸ç”¨ç®¡ï¼‰
    // æ„é€ ä¾èµ–æ³¨å…¥å™¨
    /* ps: iocä¸€å®šè¦ä¼ å…¥constæŒ‡é’ˆï¼Œå¦åˆ™diå†…éƒ¨ä¼šåˆ›å»ºå…¶ä»–å®ä¾‹ */
    const auto injector = di::make_injector(
        di::bind<boost::asio::io_context>().to(ioc_),
        di::bind<DbPoolConfig>().to(db_pool_config),
        di::bind<AsyncConnectionPool>().in(di::singleton),
        di::bind<UserDao>().in(di::singleton),
        di::bind<RedisConfig>().to(redis_config),
        di::bind<RedisClient>().in(di::singleton),
        di::bind<IVerificationCodeGenerator>().to<CodeGenerator>().in(di::singleton),
        di::bind<IVerificationCodeRepository>().to<VerificationCodeRepository>().in(di::singleton),
        di::bind<IUserRepository>().to<UserRepository>().in(di::singleton),
        di::bind<IAuthService>().to<AuthService>().in(di::singleton),
        di::bind<IBasicUserService>().to<BasicUserService>().in(di::singleton)
    );
    // è·å–æ ¸å¿ƒèµ„æºï¼ˆåé¢éœ€è¦åˆå§‹åŒ–ï¼‰
    redis_client_ = injector.create<std::shared_ptr<RedisClient>>();
    db_pool_ = injector.create<std::shared_ptr<AsyncConnectionPool>>();
    // åˆ›å»º Server å’Œ ThreadPool
    thread_pool_ = injector.create<std::unique_ptr<AsioThreadPool>>();
    server_ = injector.create<std::unique_ptr<UserServiceServer>>();
    SPDLOG_INFO("Application constructed.");
}

Application::~Application() = default;

void Application::Run() const {
    try {
        // å¯åŠ¨çº¿ç¨‹æ± 
        SPDLOG_INFO("Application: Starting Thread Pool...");
        SPDLOG_INFO("DEBUG CHECK: Application ioc address: {}", fmt::ptr(ioc_.get()));
        thread_pool_->Run();

        SPDLOG_INFO("Application: Waiting for infrastructure init...");
        // åŒæ­¥ç­‰å¾…ï¼Œåˆå§‹åŒ–å®Œæˆåæ‰èƒ½å¼€å§‹ç›‘å¬
        std::future<void> init_future = boost::asio::co_spawn(*ioc_, [this]() -> boost::asio::awaitable<void> {
            try {
                // Redis åˆå§‹åŒ–
                co_await redis_client_->Init();
                SPDLOG_INFO("Redis connected.");
                // æ•°æ®åº“è¿æ¥æ±  åˆå§‹åŒ–
                co_await db_pool_->Init();
                SPDLOG_INFO("Database connected.");
            } catch (const std::exception& e) {
                SPDLOG_CRITICAL("Infrastructure init failed: {}", e.what());
                throw;
            }
        }, boost::asio::use_future);
        init_future.get();

        // å¯åŠ¨ Server
        SPDLOG_INFO("Application: Starting gRPC Server...");
        server_->Run();
    } catch (const std::exception& e) {
        SPDLOG_CRITICAL("Application runtime error: {}", e.what());
        throw;
    }
}
```

='='=' File: ./UserService/server/user_service_server.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once

#include <UserService/v1/user_service.grpc.pb.h>
#include "service/interface/i_basic_user_service.h"
#include "service/interface/i_auth_service.h"
#include <thread>
#include <grpcpp/grpcpp.h>
#include <boost/asio/io_context.hpp>

namespace user_service::server
{
    class UserServiceServer
    {
    public:
        UserServiceServer(const std::shared_ptr<service::IAuthService>& auth_service,
            const std::shared_ptr<service::IBasicUserService>& basic_service,
            const std::shared_ptr<boost::asio::io_context>& ioc);
        ~UserServiceServer();
        void Run();
        void Shutdown();
    private:
        void HandleRpc() const;
        std::unique_ptr<grpc::ServerCompletionQueue> cq_;
        proto::v1::AuthService::AsyncService auth_grpc_service_;
        proto::v1::UserService::AsyncService basic_user_grpc_service_;
        std::unique_ptr<grpc::Server> server_;
        std::vector<std::thread> worker_threads_;

        const std::shared_ptr<boost::asio::io_context> ioc_;
        std::shared_ptr<service::IAuthService> auth_business_service_;
        std::shared_ptr<service::IBasicUserService> basic_user_business_service_;
    };
}
```

='='=' File: ./UserService/server/application.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <string>
#include <memory>
#include <boost/asio.hpp>

namespace user_service::infrastructure {
    class AsioThreadPool;
    class RedisClient;
    class AsyncConnectionPool;
}

namespace user_service::server {
    class UserServiceServer;
    class Application {
    public:
        explicit Application(std::string&& config_filepath);
        ~Application();

        // ä¸å…è®¸æ‹·è´å¤åˆ¶
        Application(const Application&) = delete;
        Application& operator=(const Application&) = delete;

        // è¿è¡Œæ•´ä¸ªç¨‹åº
        void Run() const;

    private:
        std::string config_path_;
        const std::shared_ptr<boost::asio::io_context> ioc_;
        std::shared_ptr<infrastructure::RedisClient> redis_client_;
        std::shared_ptr<infrastructure::AsyncConnectionPool> db_pool_;
        std::unique_ptr<infrastructure::AsioThreadPool> thread_pool_;
        std::unique_ptr<UserServiceServer> server_;
    };
}
```

='='=' File: ./UserService/adapter/v1/interface/i_call_data.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once

namespace user_service {
    class ICallData {
    public:
        virtual ~ICallData() = default;
        virtual void Proceed() = 0;
    };
}
```

='='=' File: ./UserService/adapter/v1/src/register_call_data.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.


#include "../include/register_call_data.h"
#include <string>
#include <boost/asio/io_context.hpp>
#include <spdlog/spdlog.h>

using namespace user_service::adapter;

RegisterCallData::RegisterCallData(v1::UserService::AsyncService *service, grpc::ServerCompletionQueue *cq,
                                   boost::asio::io_context &ioc, const std::shared_ptr<service::IBasicUserService>& basic_user_service)
    : service_(service), cq_(cq), responder_(&ctx_), status_(State::CREATE), ioc_(ioc), basic_user_service_(basic_user_service) {
}

void RegisterCallData::Init() {
    Proceed();
}

void RegisterCallData::Proceed() {
    switch (status_) {
        case State::CREATE:
            HandleCreate();
            break;
        case State::PROCESS:
            HandleProcess();
            break;
        case State::FINISH:
            HandleFinish();
            break;
    }
}

void RegisterCallData::HandleCreate() {
    status_ = State::PROCESS;
    service_->RequestRegister(&ctx_, &request_, &responder_, cq_, cq_, this);
}

void RegisterCallData::HandleProcess() {
    (new RegisterCallData(service_, cq_, ioc_, basic_user_service_))->Init();
    /*
     * 2ä¸ªé™·é˜±ï¼š
     *  1.çŠ¶æ€æ”¹å˜ä¸èƒ½ç”±asioçº¿ç¨‹æ‰§è¡Œï¼Œå¿…é¡»æ˜¯å·¥ä½œçº¿ç¨‹
     *      æŒ‡ä»¤é‡æ’åˆ—ä¼šæ‰“ä¹±é¡ºåºï¼Œä»–åªä¿è¯å•çº¿ç¨‹å†…ç»“æœæ­£ç¡®ï¼Œç”±äºæ”¹å˜statuså’Œè§¦å‘æ”¾å›cqå•çº¿ç¨‹å†…ä¸ç›¸å¹²ï¼Œæ‰€ä»¥å¯èƒ½æŒ‡ä»¤é‡æ’åˆ—
     *  2.çŠ¶æ€æ”¹å˜éœ€è¦æ”¾åœ¨å¯åŠ¨åç¨‹å‰
     *      è¦ä¿è¯asioçº¿ç¨‹è§¦å‘æ”¾å›cqå‘ç”Ÿå‰ï¼Œstatusçš„çŠ¶æ€è¢«æ”¹ä¸ºfinish
     */
    status_ = State::FINISH;
    SPDLOG_DEBUG("start register coroutine");
    boost::asio::co_spawn(ioc_,
        [this] { return RunLogic(); },
        [this](std::exception_ptr e) { OnLogicFinished(e); }
    );
}

void RegisterCallData::HandleFinish() {
    delete this;
}

boost::asio::awaitable<void> RegisterCallData::RunLogic() {
    SPDLOG_DEBUG("run RunLogic");
    std::string prefix("Hello, ");
    reply_.set_user_id(prefix + request_.username());
    co_return;
}

void RegisterCallData::OnLogicFinished(std::exception_ptr e) {
    SPDLOG_DEBUG("run OnLogicFinished");
    grpc::Status status;

    if (e) {
        std::string error_message = "Internal server error";
        try {
            std::rethrow_exception(e);
        } catch (const std::exception &ex) {
            error_message = ex.what();
            SPDLOG_ERROR("Coroutine finished with error: {}", error_message);
        } catch (...) {
            error_message = "Unknown exception type";
            SPDLOG_ERROR("Coroutine finished with non-standard exception.");
        }
        status = grpc::Status(grpc::StatusCode::INTERNAL, error_message);
    } else {
        // åç¨‹æˆåŠŸå®Œæˆ
        SPDLOG_DEBUG("Coroutine finished successfully for user: {}", request_.username());
        status = grpc::Status::OK;
    }

    // è°ƒç”¨ Finish
    responder_.Finish(reply_, status, this);
}

```

='='=' File: ./UserService/adapter/v1/include/register_call_data.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once


#include "../interface/i_call_data.h"
#include <UserService/v1/user_service.grpc.pb.h>
#include "service/interface/i_basic_user_service.h"
#include <boost/asio/co_spawn.hpp>
#include <grpcpp/completion_queue.h>
#include <grpcpp/server_context.h>
#include <grpcpp/support/async_unary_call.h>


namespace user_service::adapter {
    class RegisterCallData: public ICallData {
    public:
        RegisterCallData(v1::UserService::AsyncService* service, grpc::ServerCompletionQueue* cq,
            boost::asio::io_context& ioc, const std::shared_ptr<service::IBasicUserService>& basic_user_service);

        void Init();

        void Proceed() override;

    private:
        void HandleCreate();

        void HandleProcess();

        void HandleFinish();

        boost::asio::awaitable<void> RunLogic();

        void OnLogicFinished(std::exception_ptr e);

        // grpc æ‰€éœ€å˜é‡
        v1::UserService::AsyncService* service_;
        grpc::ServerCompletionQueue* cq_;
        grpc::ServerContext ctx_;
        grpc::ServerAsyncResponseWriter<v1::RegisterResponse> responder_;

        v1::RegisterRequest request_;
        v1::RegisterResponse reply_;

        enum class State { CREATE, PROCESS, FINISH };
        State status_;


        // åç¨‹æ‰€éœ€å˜é‡
        boost::asio::io_context& ioc_;

        std::shared_ptr<service::IBasicUserService> basic_user_service_;


    };
}
```

='='=' File: ./UserService/adapter/v2/call_data/interface/call_data.hpp '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "adapter/v2/call_data/interface/i_call_data.h"
#include "adapter/v2/call_data_manager/interface/call_data_manager.hpp"
#include <boost/asio/co_spawn.hpp>
#include <spdlog/spdlog.h>
#include <grpcpp/grpcpp.h>

namespace user_service::adapter::v2 {

    template<typename T>
    concept HasRunSpecificLogic = requires(T& derived) {
        // ä¼ å…¥ T& æ˜¯å› ä¸ºå¦‚æœä¼ å…¥Tï¼ŒTæ˜¯å¿…é¡»å¯ç§»åŠ¨å¯å¤åˆ¶çš„ï¼Œä½†T& æ²¡æœ‰è¿™ä¸ªè¦æ±‚
        /*
         * requires è¯­å¥æ£€æŸ¥ï¼š
         * 1. æ˜¯å¦å­˜åœ¨ä¸€ä¸ªåä¸º RunSpecificLogic çš„æˆå‘˜å‡½æ•°
         * 2. å®ƒè¢«è°ƒç”¨æ—¶ï¼Œè¿”å›çš„ç±»å‹æ˜¯å¦ä¸ boost::asio::awaitable<void> ç›¸åŒ
         */
        { derived.RunSpecificLogic() } -> std::same_as<boost::asio::awaitable<void>>;
    };

    /*
     * ç‰¹å®šç±»å‹çš„ CallData çš„å…¬å…±éƒ¨åˆ†ï¼Œå³ï¼šè®©ç¼–è¯‘å™¨æ›¿æˆ‘ç”Ÿæˆæ¯ä¸ªæ¥å£å¯¹åº”çš„CallDataã€‚
     * ä½†æ˜¯æ¯ä¸ªCallDataéƒ½æœ‰ä¸ä¸€æ ·çš„åœ°æ–¹ï¼Œä¸ä¸€æ ·çš„åœ°æ–¹å†ç»§æ‰¿ä¸€ä¸ªå­ç±»é‡å†™
     */
    template<typename RequestType, typename ResponseType, typename ManagerType, typename SpecificCallDataType>
    class CallData : public ICallData {
    public:
        explicit CallData(ManagerType* manager) : status_(State::WAIT_PROCESSING), manager_(manager), responder_(&ctx_) {
            static_assert(std::is_base_of_v<ICallDataManager, ManagerType>, "ManagerType must derive from ICallDataManager");
        }

        ~CallData() override = default;

        void Proceed() override {
            switch (status_) {
                case State::WAIT_PROCESSING:
                    HandleProcess();
                    break;
                case State::FINISHED:
                    HandleFinish();
                    break;
            }
        }

        void HandleProcess() {
            /*
             * 2ä¸ªé™·é˜±ï¼š
             *  1.çŠ¶æ€æ”¹å˜ä¸èƒ½ç”± asioçº¿ç¨‹ æ‰§è¡Œï¼Œå¿…é¡»æ˜¯å·¥ä½œçº¿ç¨‹
             *      æŒ‡ä»¤é‡æ’åˆ—ä¼šæ‰“ä¹±é¡ºåºï¼Œä»–åªä¿è¯å•çº¿ç¨‹å†…ç»“æœæ­£ç¡®ï¼Œç”±äºæ”¹å˜ status å’Œ è§¦å‘æ”¾å›CQ å•çº¿ç¨‹å†…ä¸ç›¸å¹²ï¼Œæ‰€ä»¥å¯èƒ½æŒ‡ä»¤é‡æ’åˆ—
             *  2.çŠ¶æ€æ”¹å˜éœ€è¦æ”¾åœ¨å¯åŠ¨åç¨‹å‰
             *      è¦ä¿è¯ asioçº¿ç¨‹ è§¦å‘æ”¾å› CQ å‘ç”Ÿå‰ï¼Œstatus çš„çŠ¶æ€è¢«æ”¹ä¸º finish
             */
            // è¿™é‡Œçš„status_æ›´æ–°å®é™…ä¸Šæ˜¯ä¸€ä¸ªé¢„å¤„ç†ï¼Œä¸ºäº†çº¿ç¨‹å®‰å…¨ï¼Œå¿…é¡»è¦å…ˆæ”¹çŠ¶æ€å†è¿›è¡Œä¸šåŠ¡é€»è¾‘
            status_ = State::FINISHED;
            SPDLOG_DEBUG("start register coroutine");

            boost::asio::co_spawn(manager_->GetIOContext(),
                                  [this] { return RunLogic(); },
                                  [this](std::exception_ptr e) { OnLogicFinished(e); }
            );
        }

        void HandleFinish() {
            // åªæœ‰å¤„äº WAIT_PROCESSING çŠ¶æ€çš„ CallDataï¼Œproceedé©±åŠ¨çš„æ—¶å€™switchæ‰ä¼šè·³è½¬æ‰§è¡Œä¸šåŠ¡é€»è¾‘
            status_ = State::WAIT_PROCESSING;
            Reset();
            // é€šè¿‡ç®¡ç†å™¨ï¼ŒæŠŠè‡ªå·±é‡æ–°æ³¨å†Œç»™ CQ
            manager_->RegisterCallDataToCQ(static_cast<SpecificCallDataType*>(this));
        }

        void Reset() {
            // ctxä¸æ”¯æŒå¤åˆ¶è¿ç®—ç¬¦ï¼Œåªèƒ½å‡ºæ­¤ä¸‹ç­–
            ctx_.~ServerContext();
            new(&ctx_) grpc::ServerContext();
            // ç»‘å®šçš„ä¸å˜çš„æˆå‘˜åœ°å€ &ctx_ï¼ˆè¿™é‡Œåªæ˜¯ä¸ºäº†è·å–æ–°çš„responderï¼‰
            responder_ = grpc::ServerAsyncResponseWriter<ResponseType>(&ctx_);
            // é‡ç½®å›å¤ï¼Œé˜²æ­¢æ•°æ®æ³„éœ²
            reply_ = ResponseType();
            // é‡ç½®è¯·æ±‚ï¼Œé‡Šæ”¾å†…å­˜
            request_ = RequestType();
        }

        boost::asio::awaitable<void> RunLogic() requires HasRunSpecificLogic<SpecificCallDataType> {
            auto* derived_this = static_cast<SpecificCallDataType*>(this);
            co_await derived_this->RunSpecificLogic();
        }
        // å…·ä½“çš„ä¸šåŠ¡é€»è¾‘éœ€è¦å­ç±»é‡å†™
        // virtual boost::asio::awaitable<void> RunLogic() = 0;

        // ä¸šåŠ¡é€»è¾‘å®Œæˆï¼Œæ³¨å†Œå› CQ
        void OnLogicFinished(std::exception_ptr e) {
            grpc::Status status;
            if (e) {
                std::string error_message = "Internal server error";
                try {
                    std::rethrow_exception(e);
                } catch (const std::exception &ex) {
                    error_message = ex.what();
                    SPDLOG_ERROR("Coroutine finished with error: {}", error_message);
                } catch (...) {
                    error_message = "Unknown exception type";
                    SPDLOG_ERROR("Coroutine finished with non-standard exception.");
                }
                status = grpc::Status(grpc::StatusCode::INTERNAL, error_message);
            } else {
                // åç¨‹æˆåŠŸå®Œæˆ
                SPDLOG_DEBUG("Coroutine finished successfully");
                status = grpc::Status::OK;
            }
            // è°ƒç”¨ Finish å°±æ˜¯æŠŠè‡ªå·±æ”¾å› CQ
            responder_.Finish(reply_, status, this);
        }
    private:
        // ä»…å†…éƒ¨ä½¿ç”¨ï¼Œcall data manager å‹å…ƒå¯è®¿é—®ï¼Œä½†ä¸è¯¥è®¿é—®
        enum class State { WAIT_PROCESSING, FINISHED };
        State status_;

    // ä¾› call data å­ç±»ä½¿ç”¨ï¼Œæ­¤å¤„éœ€è¦è®¾ç½®ä¸º protected
    protected:
        // æä¾›æˆå‘˜å˜é‡çš„ç§æœ‰æ–¹æ³•ä¾›å¯¹åº” manager(å‹å…ƒ) è°ƒç”¨
        RequestType* GetRequestAddress() {
            return &request_;
        }
        grpc::ServerContext* GetContextAddress() {
            return &ctx_;
        }
        grpc::ServerAsyncResponseWriter<ResponseType>* GetResponderAddress() {
            return &responder_;
        }
        ManagerType* manager_;
        RequestType request_;
        ResponseType reply_;
        grpc::ServerContext ctx_;
        grpc::ServerAsyncResponseWriter<ResponseType> responder_;
    };
}

```

='='=' File: ./UserService/adapter/v2/call_data/interface/i_call_data.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <boost/asio/co_spawn.hpp>
#include <spdlog/spdlog.h>
#include <grpcpp/grpcpp.h>

#include "adapter/v2/call_data_manager/interface/call_data_manager.hpp"

namespace user_service::adapter::v2 {
    class ICallData {
    public:
        explicit ICallData() {}
        virtual ~ICallData() = default;

        // HandleRpc ä¸­ CQ ç»™å‡ºè¿”å› calldata æ—¶è°ƒç”¨ï¼Œç”¨äºé©±åŠ¨ calldata
        virtual void Proceed() = 0;
    };


}

```

='='=' File: ./UserService/adapter/v2/call_data/src/register_call_data.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "adapter/v2/call_data/include/register_call_data.h"
#include "adapter/v2/call_data_manager/include/register_call_data_manager.h"
#include "service/interface/i_basic_user_service.h"

using namespace user_service::adapter::v2;


RegisterCallData::RegisterCallData(RegisterCallDataManager* manager): CallData(manager) {

}

RegisterCallData::~RegisterCallData() = default;

boost::asio::awaitable<void> RegisterCallData::RunSpecificLogic() {
    SPDLOG_DEBUG("run RunLogic");
    auto* basic_user_service = manager_->GetBusinessService();
    const service::RegisterRequest register_request(request_.username(), request_.password(),
        request_.phone_number(), request_.code());
    SPDLOG_DEBUG("ready to enter coroutine");
    service::RegisterResponse register_response = co_await basic_user_service->Register(register_request);
    SPDLOG_DEBUG("leave from coroutine");
    proto::v1::CommonStatus* status = reply_.mutable_status();
    status->set_code(static_cast<std::int32_t>(register_response.status.code));
    status->set_message(register_response.status.message);
    reply_.set_user_id(register_response.user_id);
    co_return;
}

```

='='=' File: ./UserService/adapter/v2/call_data/src/send_code_call_data.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "adapter/v2/call_data/include/send_code_call_data.h"
#include "adapter/v2/call_data_manager/include/send_code_call_data_manager.h"
#include "service/interface/i_auth_service.h"
#include "service/model/common_model.h"

using namespace user_service::adapter::v2;


SendCodeCallData::SendCodeCallData(SendCodeCallDataManager* manager): CallData(manager) {

}

SendCodeCallData::~SendCodeCallData() = default;

boost::asio::awaitable<void> SendCodeCallData::RunSpecificLogic() {
    SPDLOG_DEBUG("run RunLogic");
    auto* auth_service = manager_->GetBusinessService();
    const service::SendCodeRequest send_code_request(request_.phone_number(), static_cast<service::CodeUsage>(request_.usage()));
    SPDLOG_DEBUG("ready to enter coroutine");
    service::SendCodeResponse send_code_response = co_await auth_service->SendCode(send_code_request);
    SPDLOG_DEBUG("leave from coroutine");
    proto::v1::CommonStatus* status = reply_.mutable_status();
    status->set_code(static_cast<std::int32_t>(send_code_response.status.code));
    status->set_message(send_code_response.status.message);
    co_return;
}

```

='='=' File: ./UserService/adapter/v2/call_data/include/register_call_data.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "adapter/v2/call_data/interface/call_data.hpp"
#include <UserService/v1/user_service.grpc.pb.h>

namespace user_service::adapter::v2 {
    class RegisterCallDataManager;
    class RegisterCallData final: public CallData<proto::v1::RegisterRequest, proto::v1::RegisterResponse, RegisterCallDataManager, RegisterCallData> {
        friend RegisterCallDataManager;
    public:
        explicit RegisterCallData(RegisterCallDataManager* manager);
        ~RegisterCallData() override;
        boost::asio::awaitable<void> RunSpecificLogic();
    };
}

```

='='=' File: ./UserService/adapter/v2/call_data/include/send_code_call_data.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "adapter/v2/call_data/interface/call_data.hpp"
#include <UserService/v1/user_service.grpc.pb.h>

namespace user_service::adapter::v2 {
    class SendCodeCallDataManager;
    class SendCodeCallData final: public CallData<proto::v1::SendCodeRequest, proto::v1::SendCodeResponse, SendCodeCallDataManager, SendCodeCallData> {
        friend SendCodeCallDataManager;
    public:
        explicit SendCodeCallData(SendCodeCallDataManager* manager);
        ~SendCodeCallData() override;
        boost::asio::awaitable<void> RunSpecificLogic();
    };
}
```

='='=' File: ./UserService/adapter/v2/call_data_manager/interface/i_call_data_manager.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <memory>
#include <UserService/v1/user_service.grpc.pb.h>
#include <grpcpp/completion_queue.h>
#include <boost/asio/io_context.hpp>

namespace user_service::adapter::v2 {
    // ICallData å®šä¹‰æ–‡ä»¶åŒ…å«äº†è¯¥æ–‡ä»¶ï¼Œè¿™é‡Œä½¿ç”¨å‰å‘å£°æ˜æ›´å¤šæ˜¯ä¸ºäº†é˜²æ­¢åµŒå¥—åŒ…å«
    class ICallData;
    // æä¾› manager ç»Ÿä¸€æ¥å£
    class ICallDataManager {
    public:
        ICallDataManager(const size_t initiate_size, const std::shared_ptr<boost::asio::io_context>& ioc, grpc::ServerCompletionQueue * cq):
            initial_size_(initiate_size), ioc_(ioc), cq_(cq) {
            if (!cq_) {
                throw std::invalid_argument("CQ cannot be null.");
            }
        }
        virtual ~ICallDataManager() = default;
        // è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°å°±ä¸€å®šè¦ç”¨ä»–çš„ç»“æœï¼ˆç¼–è¯‘æœŸä¿è¯ï¼‰
        [[nodiscard]] boost::asio::io_context& GetIOContext() const {
            return *ioc_;
        }
    protected:
        size_t initial_size_;
        std::shared_ptr<boost::asio::io_context> ioc_;
        grpc::ServerCompletionQueue *cq_;
    };

}

```

='='=' File: ./UserService/adapter/v2/call_data_manager/interface/call_data_manager.hpp '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "adapter/v2/call_data_manager/interface/i_call_data_manager.h"
#include <UserService/v1/user_service.grpc.pb.h>
#include <type_traits> // for std::is_base_of
#include <vector>
#include <memory>
#include <grpcpp/completion_queue.h>
#include <boost/asio/io_context.hpp>


namespace user_service::adapter::v2 {

    template<typename T, typename SpecificCallDataType>
    concept HasSpecificRegisterCallDataToCQ = requires(T& derived) {
        /*
         * 1. std::declval è¡¨ç¤ºå‡è®¾ä¼ å…¥ä¸€ä¸ªå€¼
         * 2. è¿”å›å¿…é¡»æ˜¯ std::same_as ä»£è¡¨ä¸èƒ½æ˜¯å¼ºè½¬å‡ºæ¥çš„ void
         */
        { derived.SpecificRegisterCallDataToCQ(std::declval<SpecificCallDataType*>()) } -> std::same_as<void>;
    };

    // æ¯ç§ç‰¹å®šç±»å‹çš„ CallData å¯¹åº”ä¸€ä¸ª Manager
    template<typename GrpcServiceType, typename CallDataType, typename BusinessServiceType, typename SpecificCallDataManagerType>
    class CallDataManager: public ICallDataManager {
    public:
        CallDataManager(const size_t initial_size, GrpcServiceType* grpc_service, BusinessServiceType* business_service,
            const std::shared_ptr<boost::asio::io_context>& ioc, grpc::ServerCompletionQueue *cq):
            ICallDataManager(initial_size, ioc, cq), grpc_service_(grpc_service), business_service_(business_service) {
            static_assert(std::is_base_of_v<ICallData, CallDataType>, "CallDataType must derive from ICallData");

            if (!grpc_service_) {
                throw std::invalid_argument("Service and CQ cannot be null.");
            }
        }

        ~CallDataManager() override = default;

        void Start() {
            // åˆå§‹åŒ– call data
            for (size_t i = 0; i < initial_size_; ++i) {
                auto derived_this = static_cast<SpecificCallDataManagerType*>(this);
                auto call_data = std::make_unique<CallDataType>(derived_this);
                RegisterCallDataToCQ(call_data.get());
                pool_.push_back(std::move(call_data));
            }
        }

        void RegisterCallDataToCQ(CallDataType* call_data) requires HasSpecificRegisterCallDataToCQ<SpecificCallDataManagerType, CallDataType> {
            // åˆ©ç”¨ CRTP å®ç°é™æ€å¤šæ€ ï¼ˆéœ€è¦ä¿è¯å­ç±»æœ‰ SpecificRegisterCallDataToCQ æ–¹æ³•ï¼‰
            auto specific_call_data_manager = static_cast<SpecificCallDataManagerType*>(this);
            specific_call_data_manager->SpecificRegisterCallDataToCQ(call_data);
        }
        // æ­¤å¤„ä¸ºåˆ©ç”¨åŠ¨æ€å¤šæ€å®ç°ï¼Œä¸ºæé«˜æ€§èƒ½ï¼Œé‡‡ç”¨ä¸Šé¢çš„é™æ€å¤šæ€
        // virtual void SpecificRegisterCallDataToCQ(CallDataType* call_data) = 0;

        BusinessServiceType* GetBusinessService() {
            return business_service_;
        }
    protected:
        GrpcServiceType * grpc_service_;
        BusinessServiceType * business_service_;
        std::vector<std::unique_ptr<CallDataType>> pool_;
    };
}

```

='='=' File: ./UserService/adapter/v2/call_data_manager/src/send_code_call_data_manager.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "adapter/v2/call_data_manager/include/send_code_call_data_manager.h"
#include "adapter/v2/call_data/include/send_code_call_data.h"

using namespace user_service::adapter::v2;

SendCodeCallDataManager::SendCodeCallDataManager(const size_t initial_size, proto::v1::AuthService::AsyncService* grpc_service,
            service::IAuthService* business_service, const std::shared_ptr<boost::asio::io_context>& ioc,
            grpc::ServerCompletionQueue *cq): CallDataManager(initial_size, grpc_service, business_service, ioc, cq) {}

SendCodeCallDataManager::~SendCodeCallDataManager() = default;

void SendCodeCallDataManager::SpecificRegisterCallDataToCQ(SendCodeCallData* call_data) const {
    grpc_service_->RequestSendCode(call_data->GetContextAddress(), call_data->GetRequestAddress(), call_data->GetResponderAddress(), cq_, cq_, call_data);
}
```

='='=' File: ./UserService/adapter/v2/call_data_manager/src/register_call_data_manager.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "adapter/v2/call_data_manager/include/register_call_data_manager.h"
#include "adapter/v2/call_data/include/register_call_data.h"

using namespace user_service::adapter::v2;

RegisterCallDataManager::RegisterCallDataManager(const size_t initial_size, proto::v1::UserService::AsyncService* grpc_service,
            service::IBasicUserService* business_service, const std::shared_ptr<boost::asio::io_context>& ioc,
            grpc::ServerCompletionQueue *cq): CallDataManager(initial_size, grpc_service, business_service, ioc, cq) {
    SPDLOG_INFO("DEBUG CHECK: RegisterCallDataManager ioc address: {}", fmt::ptr(ioc_.get()));
}

RegisterCallDataManager::~RegisterCallDataManager() = default;

void RegisterCallDataManager::SpecificRegisterCallDataToCQ(RegisterCallData* call_data) const {

    // grpc_service_->RequestRegister(&call_data->ctx_, &call_data->request_, &call_data->responder_, cq_, cq_, call_data);
    grpc_service_->RequestRegister(call_data->GetContextAddress(), call_data->GetRequestAddress(), call_data->GetResponderAddress(), cq_, cq_, call_data);

}
```

='='=' File: ./UserService/adapter/v2/call_data_manager/include/send_code_call_data_manager.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "adapter/v2/call_data_manager/interface/call_data_manager.hpp"
#include "service/interface/i_auth_service.h"

namespace user_service::adapter::v2 {
    class SendCodeCallData;
    class SendCodeCallDataManager final: public CallDataManager<proto::v1::AuthService::AsyncService, SendCodeCallData, service::IAuthService, SendCodeCallDataManager> {
        friend SendCodeCallData;
    public:
        SendCodeCallDataManager(size_t initial_size, proto::v1::AuthService::AsyncService* grpc_service,
            service::IAuthService* business_service, const std::shared_ptr<boost::asio::io_context>& ioc,
            grpc::ServerCompletionQueue *cq);

        ~SendCodeCallDataManager() override;

        void SpecificRegisterCallDataToCQ(SendCodeCallData* call_data) const;
    };
}
```

='='=' File: ./UserService/adapter/v2/call_data_manager/include/register_call_data_manager.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "adapter/v2/call_data_manager/interface/call_data_manager.hpp"
#include "service/interface/i_basic_user_service.h"

namespace user_service::adapter::v2 {
    class RegisterCallData;
    class RegisterCallDataManager final: public CallDataManager<proto::v1::UserService::AsyncService, RegisterCallData, service::IBasicUserService, RegisterCallDataManager> {
        friend RegisterCallData;
    public:
        RegisterCallDataManager(size_t initial_size, proto::v1::UserService::AsyncService* grpc_service,
            service::IBasicUserService* business_service, const std::shared_ptr<boost::asio::io_context>& ioc,
            grpc::ServerCompletionQueue *cq);

        ~RegisterCallDataManager() override;

        void SpecificRegisterCallDataToCQ(RegisterCallData* call_data) const;
    };
}
```

='='=' File: ./UserService/config/app_config.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "config/app_config.h"

using namespace user_service::config;
using namespace user_service::infrastructure;

AppConfig::AppConfig(const std::string& config_path) {
    try {
        SPDLOG_INFO("Loading configuration from: {}", config_path);
        const YAML::Node root_node = YAML::LoadFile(config_path);
        ParseRedisConfig(root_node);
        ParseDbConfig(root_node);
    } catch (const YAML::Exception& e) {
        SPDLOG_CRITICAL("Error parsing YAML file '{}': {}", config_path, e.what());
        throw std::runtime_error("Configuration load failed");
    } catch (const std::exception& e) {
        SPDLOG_CRITICAL("Configuration error: {}", e.what());
        throw;
    }
}

RedisConfig AppConfig::GetRedisConfig() const {
    return redis_config;
}

DbPoolConfig AppConfig::GetDBPoolConfig() const {
    return db_pool_config;
}

void AppConfig::ParseRedisConfig(const YAML::Node& root_node) {
    // è¯»å€¼
    if (!root_node["redis"]) {
        throw std::runtime_error("Missing 'redis' section");
    }
    const auto& redis_node = root_node["redis"];

    // å–å€¼
    std::string host = redis_node["host"].as<std::string>();
    int port = redis_node["port"].as<int>();

    // æ ¡éªŒ
    ValidateNotEmpty(host, "Redis Host");
    ValidatePort(port, "Redis Port");

    // èµ‹å€¼
    redis_config.host = host;
    redis_config.port = std::to_string(port); // RedisConfig é‡Œä¾ç„¶å­˜çš„æ˜¯ string
    SPDLOG_INFO("Redis config loaded: {}:{}", redis_config.host, redis_config.port);
}

void AppConfig::ParseDbConfig(const YAML::Node& root_node) {
    // è¯»å€¼
    if (!root_node["postgresql"]) {
        throw std::runtime_error("Missing 'postgresql' section");
    }
    const auto& db_node = root_node["postgresql"];

    // å–å€¼
    std::string host = db_node["host"].as<std::string>();
    int port = db_node["port"].as<int>();
    std::string user = db_node["user"].as<std::string>();
    std::string pwd = db_node["password"].as<std::string>();
    std::string dbname = db_node["dbname"].as<std::string>();
    int pool_size = db_node["pool_size"].as<int>();

    // æ ¡éªŒ
    ValidateNotEmpty(host, "DB Host");
    ValidateNotEmpty(user, "DB User");
    ValidateNotEmpty(dbname, "DB Name");
    ValidatePort(port, "DB Port");
    if (pool_size <= 0 || pool_size > 1000) {
        throw std::runtime_error(fmt::format("Config Error: Invalid DB pool_size {}", pool_size));
    }

    // èµ‹å€¼
    db_pool_config.conn_str = fmt::format("postgresql://{}:{}@{}:{}/{}",
                                          user, pwd, host, port, dbname);
    db_pool_config.pool_size = pool_size;
    SPDLOG_INFO("Database config loaded. Host: {}, PoolSize: {}", host, db_pool_config.pool_size);
}

void AppConfig::ValidatePort(int port, const std::string& field_name) const {
    if (port <= 0 || port > 65535) {
        throw std::runtime_error(
            fmt::format("Config Error: {} value '{}' is invalid. Must be between 1 and 65535", field_name, port)
        );
    }
}

void AppConfig::ValidateNotEmpty(const std::string& value, const std::string& field_name) const {
    if (value.empty()) {
        throw std::runtime_error(fmt::format("Config Error: '{}' cannot be empty", field_name));
    }
}
```

='='=' File: ./UserService/config/app_config.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <string>
#include <yaml-cpp/yaml.h>
#include "infrastructure/state_storage/redis_dao/redis_client.h"
#include "infrastructure/persistence/postgresql/include/async_connection_pool.h"

namespace user_service::config {
    class AppConfig {
    public:
        explicit AppConfig(const std::string& config_path);

        // é…ç½®å¯¹è±¡ä¸å…è®¸æ‹·è´ã€èµ‹å€¼
        AppConfig(const AppConfig&) = delete;
        AppConfig& operator=(const AppConfig&) = delete;

        infrastructure::RedisConfig GetRedisConfig() const;
        infrastructure::DbPoolConfig GetDBPoolConfig() const;

    private:
        // YAML::Nodeï¼Œä»£è¡¨é…ç½®æ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹
        void ParseRedisConfig(const YAML::Node& root_node);
        void ParseDbConfig(const YAML::Node& root_node);

        /* æ ¡éªŒé€»è¾‘ */
        void ValidatePort(int port, const std::string& field_name) const;
        void ValidateNotEmpty(const std::string& value, const std::string& field_name) const;

        infrastructure::RedisConfig redis_config;
        infrastructure::DbPoolConfig db_pool_config;
    };
}
```

='='=' File: ./UserService/config/config.yaml '='='='
```
# config.yaml
server:
  port: 50051

redis:
  host: "grpc-dev-redis.bbqzfi.ng.0001.apse1.cache.amazonaws.com"
  port: 6379

postgresql:
  host: "grpc-dev-database.cvosiiw6iypg.ap-southeast-1.rds.amazonaws.com"
  port: 5432
  user: "lxy"
  password: "12345678"
  dbname: "postgres"
  pool_size: 4
```

='='=' File: ./UserService/service/interface/i_auth_service.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "../model/auth_model.h"
#include <boost/asio.hpp>

namespace user_service::service {

    class IAuthService {
    public:
        virtual ~IAuthService() = default;
        virtual boost::asio::awaitable<SendCodeResponse> SendCode(const SendCodeRequest&) = 0;
        virtual boost::asio::awaitable<LoginResult> LoginByCode(const LoginByCodeRequest&) = 0;
        virtual boost::asio::awaitable<LoginResult> LoginByPassword(const LoginByPasswordRequest&) = 0;
    };
}
```

='='=' File: ./UserService/service/interface/i_basic_user_service.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "../model/basic_user_model.h"
#include <boost/asio.hpp>

namespace user_service::service {
    class IBasicUserService {
    public:
        virtual ~IBasicUserService() = default;
        virtual boost::asio::awaitable<RegisterResponse> Register(const RegisterRequest&) = 0;
        virtual boost::asio::awaitable<GetUserInfoResponse> GetUserInfo(const GetUserInfoRequest&) = 0;
        virtual boost::asio::awaitable<UpdateUserInfoResponse> UpdateUserInfo(const UpdateUserInfoRequest&) = 0;
    };
}
```

='='=' File: ./UserService/service/src/basic_user_service.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/basic_user_service.h"
#include <spdlog/spdlog.h>

using namespace user_service::service;

BasicUserService::BasicUserService() {
    SPDLOG_DEBUG("Execute BasicUserService Constructor");
}

BasicUserService::~BasicUserService() = default;

boost::asio::awaitable<RegisterResponse> BasicUserService::Register(const RegisterRequest& register_request) {
    std::string prefix("Hello,  ");
    RegisterResponse register_response(CommonStatus::Success(), prefix+register_request.username);
    SPDLOG_DEBUG("register_response: {}", register_response.user_id);
    co_return register_response;
}

boost::asio::awaitable<GetUserInfoResponse> BasicUserService::GetUserInfo(const GetUserInfoRequest&) {

}

boost::asio::awaitable<UpdateUserInfoResponse> BasicUserService::UpdateUserInfo(const UpdateUserInfoRequest&) {

}
```

='='=' File: ./UserService/service/src/auth_service.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/auth_service.h"
#include "service/model/common_model.h"
#include <spdlog/spdlog.h>


using namespace user_service::service;

AuthService::AuthService(const std::shared_ptr<util::IVerificationCodeGenerator>& code_generator,
                         const std::shared_ptr<domain::IVerificationCodeRepository>& code_repository,
                         const std::shared_ptr<domain::IUserRepository>& user_repository):
    verification_code_generator_(code_generator), verification_code_repository_(code_repository), user_repository_(user_repository)
{
    SPDLOG_DEBUG("Execute AuthService Constructor");
}

AuthService::~AuthService() = default;

boost::asio::awaitable<SendCodeResponse> AuthService::SendCode(const SendCodeRequest& send_code_request)
{
    // 1. æŸ¥è¯¢ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    bool user_exists = false;
    // 2. æ ¹æ®éªŒè¯ç ç”¨é€”è¿›è¡Œé€»è¾‘æ ¡éªŒ
    switch (send_code_request.usage)
    {
    case USER_REGISTER:
        if (user_exists)
        {
            SPDLOG_WARN("Registration failed: User {} already exists", send_code_request.phone_number);
            co_return SendCodeResponse(CommonStatus(ErrorCode::USER_NOT_FOUND, "è¯¥æ‰‹æœºå·å·²æ³¨å†Œ"));
        }
        break;
    case USER_LOGIN:
        if (!user_exists)
        {
            co_return SendCodeResponse(CommonStatus(ErrorCode::USER_NOT_FOUND, "è¯¥æ‰‹æœºå·å°šæœªæ³¨å†Œ"));
        }
        break;
    case RESET_PASSWORD:
        if (!user_exists)
        {
            co_return SendCodeResponse(CommonStatus(ErrorCode::USER_NOT_FOUND, "è¯¥æ‰‹æœºå·å°šæœªæ³¨å†Œ"));
        }
        break;
    default:
        co_return SendCodeResponse(CommonStatus(ErrorCode::INVALID_ARGUMENT, "å‘é€éªŒè¯ç ç”¨é€”ä¸æ˜"));
    }
    // 3. ç”ŸæˆéªŒè¯ç 
    std::string code = verification_code_generator_->Generate(6);
    // 4. æ¨¡æ‹Ÿå‘é€éªŒè¯ç 
    SPDLOG_DEBUG("send code {} to {}", code, send_code_request.phone_number);
    // 5. å­˜åˆ° redis
    const auto expiry = std::chrono::minutes(5); // TTL: 5åˆ†é’Ÿ
    co_await verification_code_repository_->SaveCode(send_code_request.usage,
                                                     send_code_request.phone_number, code, expiry);
    SPDLOG_DEBUG("Verification code saved to Redis successfully");

    co_return SendCodeResponse(CommonStatus::Success());
}

boost::asio::awaitable<LoginResult> AuthService::LoginByCode(const LoginByCodeRequest& login_by_code_request)
{
}

boost::asio::awaitable<LoginResult> AuthService::LoginByPassword(
    const LoginByPasswordRequest& login_by_password_request)
{
}

```

='='=' File: ./UserService/service/include/auth_service.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "service/interface/i_auth_service.h"
#include "utils/interface/i_verification_code_generator.h"
#include "domain/interface/i_verification_code_repository.h"
#include "domain/interface/i_user_repository.h"


namespace user_service::service {
    class AuthService final: public IAuthService {
    public:
        explicit AuthService(const std::shared_ptr<util::IVerificationCodeGenerator>& code_generator,
            const std::shared_ptr<domain::IVerificationCodeRepository>& code_repository,
            const std::shared_ptr<domain::IUserRepository>& user_repository);
        ~AuthService() override;
        boost::asio::awaitable<SendCodeResponse> SendCode(const SendCodeRequest&) override;
        boost::asio::awaitable<LoginResult> LoginByCode(const LoginByCodeRequest&) override;
        boost::asio::awaitable<LoginResult> LoginByPassword(const LoginByPasswordRequest&) override;
    private:
        std::shared_ptr<util::IVerificationCodeGenerator> verification_code_generator_;
        std::shared_ptr<domain::IVerificationCodeRepository> verification_code_repository_;
        std::shared_ptr<domain::IUserRepository> user_repository_;
    };
}

```

='='=' File: ./UserService/service/include/basic_user_service.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "service/interface/i_basic_user_service.h"

namespace user_service::service {
    class BasicUserService final: public IBasicUserService {
    public:
        BasicUserService();
        ~BasicUserService() override;
        boost::asio::awaitable<RegisterResponse> Register(const RegisterRequest&) override;
        boost::asio::awaitable<GetUserInfoResponse> GetUserInfo(const GetUserInfoRequest&) override;
        boost::asio::awaitable<UpdateUserInfoResponse> UpdateUserInfo(const UpdateUserInfoRequest&) override;
    };
}

```

='='=' File: ./UserService/service/model/auth_model.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "service/model/common_model.h"
#include <string>

namespace user_service::service {
    // å‘é€éªŒè¯ç 
    enum CodeUsage {
        UNKNOWN = 0,
        USER_REGISTER = 1,
        USER_LOGIN = 2,
        RESET_PASSWORD = 3,
    };
    struct SendCodeRequest {
        std::string phone_number;
        CodeUsage usage;
    };
    struct SendCodeResponse {
        CommonStatus status;
    };

    // å¯†ç ç™»å½•
    struct LoginByPasswordRequest {
        std::string username;
        std::string password;
    };
    // éªŒè¯ç ç™»å½•
    struct LoginByCodeRequest {
        std::string phone_number;
        std::string code;
    };
    // ç™»å½•ç»“æœ
    struct LoginResult {
        CommonStatus status;
        std::string token;
        std::string user_id;
    };
}

```

='='=' File: ./UserService/service/model/basic_user_model.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "service/model/common_model.h"
#include <string>

namespace user_service::service {
    // æ³¨å†Œ
    struct RegisterRequest {
        std::string username;
        std::string password;
        std::string phone_number;
        std::string code;
    };

    struct RegisterResponse {
        CommonStatus status;
        std::string user_id;
    };

    // è·å–ä¿¡æ¯
    struct GetUserInfoRequest {
        std::string user_id;
    };
    struct GetUserInfoResponse {
        CommonStatus status;
        std::string user_id;
        std::string username;
        std::string email;
        std::string avatar_url;
    };

    // æ›´æ–°ä¿¡æ¯
    struct UpdateUserInfoRequest {
        std::string username;
        std::string email;
        std::string avatar_url;
    };

    struct UpdateUserInfoResponse {
        CommonStatus status;
    };
}


```

='='=' File: ./UserService/service/model/common_model.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <string>
#include <cstdint>

namespace user_service::service {
    enum class ErrorCode: std::int32_t {
        SUCCESS = 0,

        // é€šç”¨é”™è¯¯
        INTERNAL_ERROR = 1000,
        INVALID_ARGUMENT = 1001,

        // ç”¨æˆ·ç›¸å…³é”™è¯¯ (2000+)
        USER_NOT_FOUND = 2001,
        USER_ALREADY_EXISTS = 2002,
        PASSWORD_INCORRECT = 2003,

        // éªŒè¯ç ç›¸å…³ (3000+)
        VERIFICATION_CODE_EXPIRED = 3001,
        VERIFICATION_CODE_MISMATCH = 3002
    };
    struct CommonStatus
    {
        ErrorCode code;
        std::string message;
        CommonStatus(): code(ErrorCode::SUCCESS), message("") {}
        CommonStatus(ErrorCode code, const std::string& msg): code(code), message(msg) {}
        static CommonStatus Success() {
            return {ErrorCode::SUCCESS, "æ“ä½œæˆåŠŸ"};
        }
    };

    // class BusinessException : public std::runtime_error {
    // public:
    //     BusinessException(const ErrorCode code, const std::string& message)
    //         : std::runtime_error(message), code_(code) {}
    //
    //     ErrorCode GetCode() const {
    //         return code_;
    //     }
    //
    // private:
    //     ErrorCode code_;
    // };
}

```

='='=' File: ./UserService/builtin_impl/builtin_impl.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include <boost/redis/src.hpp>

```

='='=' File: ./UserService/init_sql/init_user_logs.sql '='='='
```
-- ç™»å½•æ—¥å¿—è¡¨ (åªå†™)
CREATE TABLE user_login_logs
(
    id       BIGSERIAL PRIMARY KEY,
    user_id  UUID NOT NULL,
    login_ip VARCHAR(45),
    login_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users (id)
);

-- åŠ ç´¢å¼•
CREATE INDEX idx_login_logs_user ON user_login_logs (user_id);
CREATE INDEX idx_login_logs_time ON user_login_logs (login_at);
```

='='=' File: ./UserService/init_sql/init_users.sql '='='='
```
CREATE TABLE users
(
    -- ä½¿ç”¨ UUIDv7
    id            UUID PRIMARY KEY,

    phone_number  VARCHAR(20)                           NOT NULL UNIQUE,
    username      VARCHAR(64) UNIQUE,
    email         VARCHAR(128) UNIQUE,

    -- å¯†ç å®‰å…¨
    password_hash VARCHAR(256)                          NOT NULL,
    salt          VARCHAR(64)                           NOT NULL,

    -- èµ„æ–™
    avatar_url    VARCHAR(512),
    status        SMALLINT    DEFAULT 0                 NOT NULL, -- 0:æ­£å¸¸, 1:å†»ç»“

    -- æ—¶é—´
    created_at    TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    deleted_at    TIMESTAMPTZ                                     -- è½¯åˆ é™¤ï¼Œä¸åˆ ç‰©ç†è¡Œ
);
```

='='=' File: ./UserService/domain/user.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "domain/user.h"

using namespace user_service::domain;

void User::ChangePassword(const std::string& new_hash, const std::string& new_salt) {
    if (new_hash.empty() || new_salt.empty()) {
        throw std::invalid_argument("Hash and salt cannot be empty");
    }
    password_hash_ = new_hash;
    salt_ = new_salt;
}

void User::UpdateProfile(std::optional<std::string> username,
                   std::optional<std::string> email,
                   std::optional<std::string> avatar_url) {
    if (username.has_value()) username_ = username;
    if (email.has_value()) email_ = email;
    if (avatar_url.has_value()) avatar_url_ = avatar_url;
}

void User::MarkAsDeleted() {
    status_ = UserStatus::DELETED;
    deleted_at_ = std::chrono::system_clock::now();
}
```

='='=' File: ./UserService/domain/user.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// All Rights Reserved

#pragma once
#include <string>
#include <optional>
#include <chrono>
// #include "infrastructure/persistence/dao/user_dao.h"

namespace user_service::infrastructure {
    class UserDao;
}

namespace user_service::domain
{
    // å¯¹åº”æ•°æ®åº“ status å­—æ®µ (SMALLINT) æŒ‡å®š16ä½å­˜å‚¨
    enum class UserStatus : int16_t
    {
        NORMAL = 0,
        FROZEN = 1,
        INACTIVE = 2,
        DELETED = 99
    };
    class User
    {
        friend class infrastructure::UserDao;   // friend & å‰å‘å£°æ˜
    public:
        using TimePoint = std::chrono::system_clock::time_point;

        /* ä¸šåŠ¡è¡Œä¸º */
        void ChangePassword(const std::string& new_hash, const std::string& new_salt); // ä¿®æ”¹å¯†ç 

        void UpdateProfile(std::optional<std::string> username,
                           std::optional<std::string> email,
                           std::optional<std::string> avatar_url); // ä¿®æ”¹ä¸ªäººèµ„æ–™

        void MarkAsDeleted(); // è½¯åˆ é™¤

        // åªè¯»
        const std::string& GetId() const { return id_; }
        const std::string& GetPhoneNumber() const { return phone_number_; }
        const std::string& GetPasswordHash() const { return password_hash_; }
        const std::string& GetSalt() const { return salt_; }

        // Optional å­—æ®µè¿”å› const æŒ‡é’ˆæˆ–è€… optional å¼•ç”¨ï¼Œæ–¹ä¾¿è°ƒç”¨è€…åˆ¤æ–­
        std::optional<std::string> GetUsername() const { return username_; }
        std::optional<std::string> GetEmail() const { return email_; }
        std::optional<std::string> GetAvatarUrl() const { return avatar_url_; }

        UserStatus GetStatus() const { return status_; }
        int GetStatusValue() const { return static_cast<int>(status_); } // ç»™ DAO å­˜åº“ç”¨

        TimePoint GetCreatedAt() const { return created_at_; }
        std::optional<TimePoint> GetDeletedAt() const { return deleted_at_; }

        // åˆ¤æ–­æ˜¯å¦å·²åˆ é™¤
        bool IsDeleted() const
        {
            return deleted_at_.has_value() || status_ == UserStatus::DELETED;
        }

    private:
        User() = default;

        std::string id_; // UUID
        std::string phone_number_;

        // è®¤è¯å®‰å…¨å­—æ®µ
        std::string password_hash_;
        std::string salt_;

        // å¯ç©ºå­—æ®µ
        std::optional<std::string> username_;
        std::optional<std::string> email_;
        std::optional<std::string> avatar_url_;

        // çŠ¶æ€ä¸æ—¶é—´
        UserStatus status_;
        TimePoint created_at_;
        std::optional<TimePoint> deleted_at_; // è½¯åˆ é™¤æ—¶é—´
    };
}

```

='='=' File: ./UserService/domain/interface/i_user_repository.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "service/model/auth_model.h"
#include <boost/asio.hpp>
#include <optional>
#include "domain/user.h"

namespace user_service::domain
{
    class IUserRepository
    {
    public:
        virtual ~IUserRepository() = default;
        virtual boost::asio::awaitable<User> GetUserByPhoneNumber(const std::string& phoneNumber) = 0;
    };
}

```

='='=' File: ./UserService/domain/interface/i_verification_code_repository.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "service/model/auth_model.h"
#include <boost/asio.hpp>
#include <optional>

namespace user_service::domain {
    class IVerificationCodeRepository {
    public:
        virtual ~IVerificationCodeRepository() = default;

        virtual boost::asio::awaitable<void> SaveCode(const service::CodeUsage& usage, const std::string& target,
            const std::string& code, std::chrono::seconds expiry) = 0;

        virtual boost::asio::awaitable<std::optional<std::string>> GetCode(const service::CodeUsage& usage, const std::string& target) = 0;
    };
}
```

='='=' File: ./UserService/infrastructure/asio_thread_pool/asio_thread_pool.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "asio_thread_pool.h"
#include <spdlog/spdlog.h>

using namespace user_service::infrastructure;

AsioThreadPool::AsioThreadPool(const std::shared_ptr<boost::asio::io_context>& ioc): ioc_(ioc) {
    SPDLOG_DEBUG("Execute AsioThreadPool Constructor");
}

AsioThreadPool::~AsioThreadPool() {
    // è¿™é‡Œä¿è¯RAII, å³ä½¿ä¸æ‰‹åŠ¨Stop, ä¹Ÿä¿è¯é‡Šæ”¾æ—¶Stop
    Stop();
}

void AsioThreadPool::Run() {
    // ä¿è¯å¹‚ç­‰
    if (work_guard_) {
        SPDLOG_WARN("AsioThreadPool is already running.");
        return;
    }

    // åˆ›å»º work_guardï¼Œé˜²æ­¢ ioc->run() æ²¡æœ‰ä»»åŠ¡å°±ç«‹å³é€€å‡º
    work_guard_.emplace(boost::asio::make_work_guard(*ioc_));

    unsigned int thread_count = std::thread::hardware_concurrency();
    if (thread_count == 0) thread_count = 2; // ä¿åº• 2 ä¸ªçº¿ç¨‹
    asio_threads_.reserve(thread_count);
    for (unsigned i = 0; i < thread_count; ++i) {
        asio_threads_.emplace_back([ioc = ioc_]() {
            SPDLOG_TRACE("start run");
            ioc->run();
            SPDLOG_TRACE("finish run");
        });
    }
    SPDLOG_INFO("Asio thread pool started with {} threads.", thread_count);
}

// åœæ­¢çº¿ç¨‹æ± 
void AsioThreadPool::Stop() {
    // ä¿è¯å¹‚ç­‰
    if (!work_guard_) {
        return;
    }
    SPDLOG_DEBUG("Stopping Asio thread pool...");

    // é‡Šæ”¾ work_guardï¼Œå…è®¸ ioc->run() é€€å‡º
    work_guard_.reset();
    if (ioc_ && !ioc_->stopped()) {
        ioc_->stop();
    }
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹é€€å‡º
    for (auto& t : asio_threads_) {
        if (t.joinable()) {
            t.join();
        }
    }
    asio_threads_.clear();
    SPDLOG_INFO("Asio thread pool stopped.");
}
```

='='=' File: ./UserService/infrastructure/asio_thread_pool/asio_thread_pool.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <vector>
#include <thread>
#include <boost/asio/io_context.hpp>
#include <spdlog/spdlog.h>
#include <optional>

namespace user_service::infrastructure {
    class AsioThreadPool {
    public:
        using work_guard_type = boost::asio::executor_work_guard<boost::asio::io_context::executor_type>;
        AsioThreadPool(const std::shared_ptr<boost::asio::io_context>& ioc);
        ~AsioThreadPool();

        // å¯åŠ¨å’Œåœæ­¢ä¸€å®šæ˜¯å¹‚ç­‰çš„
        void Run();
        void Stop();

    private:
        const std::shared_ptr<boost::asio::io_context> ioc_;
        std::optional<work_guard_type> work_guard_;
        std::vector<std::thread> asio_threads_;
    };
}
```

='='=' File: ./UserService/infrastructure/domain_implement/src/user_repository.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/user_repository.h"

using namespace user_service::infrastructure;
using namespace user_service::domain;

UserRepository::UserRepository(const std::shared_ptr<UserDao>& user_dao): user_dao_(user_dao) {

}

UserRepository::~UserRepository() = default;

boost::asio::awaitable<User> UserRepository::GetUserByPhoneNumber(const std::string& phoneNumber) {

}
```

='='=' File: ./UserService/infrastructure/domain_implement/src/verification_code_repository.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/verification_code_repository.h"

#include "spdlog/spdlog.h"

using namespace user_service::infrastructure;
using namespace user_service::service;

VerificationCodeRepository::VerificationCodeRepository(
    const std::shared_ptr<RedisClient>& redis_client) : redis_client_(redis_client)
{
    SPDLOG_DEBUG("Execute VerificationCodeRepository Constructor");
}

VerificationCodeRepository::~VerificationCodeRepository() = default;

boost::asio::awaitable<void> VerificationCodeRepository::SaveCode(const CodeUsage& usage, const std::string& target,
                                                                  const std::string& code, std::chrono::seconds expiry)
{
    std::string redis_key;
    try {
        // æ„å»º key
        redis_key = GetKeyPrefixForUsage(usage) + target;
    } catch (const std::invalid_argument& e) {
        SPDLOG_ERROR("Failed to save code due to invalid usage type: {}", e.what());
        co_return;
    }
    SPDLOG_DEBUG("Saving code to redis. Key: [{}], Code: [{}], Expiry: [{}s]",
                 redis_key, code, expiry.count());
    co_await redis_client_->Set(redis_key, code, expiry);
}

boost::asio::awaitable<std::optional<std::string>> VerificationCodeRepository::GetCode(const CodeUsage& usage, const std::string& target)
{
    std::string redis_key;
    try {
        // æ„å»º key
        redis_key = GetKeyPrefixForUsage(usage) + target;
    } catch (const std::invalid_argument& e) {
        SPDLOG_ERROR("Failed to get code due to invalid usage type: {}", e.what());
        co_return std::nullopt;
    }
    SPDLOG_DEBUG("Getting code from redis. Key: [{}]", redis_key);
    co_return co_await redis_client_->Get(redis_key);
}

std::string VerificationCodeRepository::GetKeyPrefixForUsage(const CodeUsage& usage) const
{
    switch (usage)
    {
    case USER_REGISTER:
        return "verify_code:register:";
    case USER_LOGIN:
        return "verify_code:login:";
    case RESET_PASSWORD:
        return "verify_code:reset_pwd:";
    default:
        SPDLOG_ERROR("Unknown CodeUsage enum value: {}", static_cast<int>(usage));
        throw std::invalid_argument("Unknown CodeUsage");
    }
}

```

='='=' File: ./UserService/infrastructure/domain_implement/include/user_repository.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "domain/interface/i_user_repository.h"
#include "infrastructure/persistence/dao/user_dao.h"

namespace user_service::infrastructure {
    class UserRepository final : public domain::IUserRepository {
    public:
        explicit UserRepository(const std::shared_ptr<UserDao>& user_dao);
        ~UserRepository() override;
        boost::asio::awaitable<domain::User> GetUserByPhoneNumber(const std::string& phoneNumber) override;
    private:
        const std::shared_ptr<UserDao> user_dao_;
    };
}

```

='='=' File: ./UserService/infrastructure/domain_implement/include/verification_code_repository.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "domain/interface/i_verification_code_repository.h"
#include "infrastructure/state_storage/redis_dao/redis_client.h"
#include "service/model/auth_model.h"

namespace user_service::infrastructure
{
    class VerificationCodeRepository final : public domain::IVerificationCodeRepository
    {
    public:
        explicit VerificationCodeRepository(const std::shared_ptr<RedisClient>& redis_client);
        ~VerificationCodeRepository() override;

        boost::asio::awaitable<void> SaveCode(const service::CodeUsage& usage, const std::string& target,
                                              const std::string& code, std::chrono::seconds expiry) override;

        boost::asio::awaitable<std::optional<std::string>> GetCode(const service::CodeUsage& usage, const std::string& target) override;

    private:
        std::string GetKeyPrefixForUsage(const service::CodeUsage& usage) const;
        const std::shared_ptr<RedisClient> redis_client_;
    };
}

```

='='=' File: ./UserService/infrastructure/state_storage/redis_dao/redis_client.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "redis_client.h"
#include <spdlog/spdlog.h>
#include <boost/redis/request.hpp>
#include <boost/redis/response.hpp>
#include <boost/redis/resp3/node.hpp>
#include <boost/redis/resp3/type.hpp>

using namespace user_service::infrastructure;

RedisClient::RedisClient(const std::shared_ptr<boost::asio::io_context>& ioc, const RedisConfig& config):
    ioc_(ioc), conn_(std::make_shared<boost::redis::connection>(boost::asio::make_strand(ioc->get_executor())))
{
    SPDLOG_DEBUG("Execute RedisClient Constructor");
    cfg_.addr.host = config.host;
    cfg_.addr.port = config.port;
}

RedisClient::~RedisClient() = default;


boost::asio::awaitable<void> RedisClient::Init() {
    SPDLOG_DEBUG("STARTING to connect redis");
    conn_->async_run(cfg_, boost::asio::detached);
    SPDLOG_DEBUG("next");

    co_await Ping();
}

boost::asio::awaitable<void> RedisClient::Set(const std::string& key, const std::string& value) {
    SPDLOG_DEBUG("SET {}: {}", key, value);
    try {
        // åˆ›å»º SET è¯·æ±‚
        boost::redis::request req;
        req.push("SET", key, value);
        // å¼‚æ­¥æ‰§è¡Œè¯·æ±‚
        co_await conn_->async_exec(req, boost::redis::ignore);
    } catch (const std::exception& e) {
        SPDLOG_ERROR("Redis SET failed: {}. Key: {}, Value: {}", e.what(), key, value);
    }
}

boost::asio::awaitable<void> RedisClient::Set(const std::string& key, const std::string& value, const std::chrono::seconds& expiry)
{
    SPDLOG_DEBUG("SET {}: {} (Expiry: {}s)", key, value, expiry.count());
    try {
        boost::redis::request req;
        // SET key value EX seconds
        req.push("SET", key, value, "EX", std::to_string(expiry.count()));
        co_await conn_->async_exec(req, boost::redis::ignore);
    } catch (const std::exception& e) {
        SPDLOG_ERROR("Redis SETEX failed: {}. Key: {}, Value: {}, Expiry: {}", e.what(), key, value, expiry.count());
    }
}

boost::asio::awaitable<std::optional<std::string>> RedisClient::Get(const std::string& key) {
    SPDLOG_DEBUG("GET {}", key);
    try {
        boost::redis::request req;
        req.push("GET", key);

        boost::redis::response<boost::redis::resp3::node> resp;
        co_await conn_->async_exec(req, resp);

        co_return ExtractResult(std::get<0>(resp), "GET", key);

    } catch (const std::exception& e) {
        SPDLOG_ERROR("Redis GET failed: {}. Key: {}", e.what(), key);
        co_return std::nullopt;
    }
}

boost::asio::awaitable<void> RedisClient::Ping() {
    boost::redis::request req;
    req.push("PING");
    boost::redis::response<boost::redis::resp3::node> resp;

    // async_exec ä¼šè‡ªåŠ¨ç­‰å¾… async_run å»ºç«‹è¿æ¥
    try {
        co_await conn_->async_exec(req, resp, boost::asio::use_awaitable);
        const auto result = ExtractResult(std::get<0>(resp), "PING");

        // é’ˆå¯¹ PING çš„ç‰¹æ®Šæ£€æŸ¥
        if (result.has_value() && result.value() == "PONG") {
            SPDLOG_INFO("Redis PING successful.");
            co_return;
        }

        // å¦‚æœæ²¡æŠ›å¼‚å¸¸ä½†æ˜¯ä¹Ÿæ²¡è¿”å› PONG (ExtractResult å†…éƒ¨å·²ç»æ‰“è¿‡ Error æ—¥å¿—äº†ï¼Œè¿™é‡ŒæŠ›å¼‚å¸¸å³å¯)
        throw std::runtime_error("Redis PING failed or returned unexpected value");

    } catch (const std::exception& e) {
        SPDLOG_ERROR("Failed to connect to Redis: {}", e.what());
        throw;
    }
}

std::optional<std::string> RedisClient::ExtractResult(const boost::system::result<boost::redis::resp3::node, boost::redis::adapter::error>& result,
            const std::string& command_name, const std::string& key_context) const {

    // A. æ£€æŸ¥ç³»ç»Ÿçº§é”™è¯¯ (æ¯”å¦‚ç½‘ç»œæ–­å¼€)
    if (result.has_error()) {
        SPDLOG_ERROR("Redis {} failed with system error: {}. Context: {}",
            command_name, result.error().diagnostic, key_context);
        return std::nullopt;
    }

    const auto& node = result.value();

    // B. æ£€æŸ¥æ˜¯å¦æ˜¯å­—ç¬¦ä¸² (Blob String æˆ– Simple String)
    // æ³¨æ„ï¼šPONG æ˜¯ simple_stringï¼ŒGET çš„å€¼é€šå¸¸æ˜¯ blob_string
    if (node.data_type == boost::redis::resp3::type::blob_string || node.data_type == boost::redis::resp3::type::simple_string) {
        return node.value;
    }

    // C. æ£€æŸ¥ Null (Key ä¸å­˜åœ¨)
    if (node.data_type == boost::redis::resp3::type::null) {
        SPDLOG_DEBUG("Redis {} key '{}' not found (NULL).", command_name, key_context);
        return std::nullopt;
    }

    // D. æ£€æŸ¥è¯­ä¹‰é”™è¯¯ (æ¯”å¦‚å‘½ä»¤å‚æ•°ä¸å¯¹)
    if (node.data_type == boost::redis::resp3::type::simple_error ||
        node.data_type == boost::redis::resp3::type::blob_error) {
        SPDLOG_ERROR("Redis {} returned Redis-Error: {}. Context: {}", command_name, node.value, key_context);
        return std::nullopt;
        }

    // E. å…¶ä»–æœªé¢„æœŸçš„ç±»å‹ (æ¯”å¦‚è¿”å›äº† Array æˆ– Int)
    SPDLOG_WARN("Redis {} returned unexpected type: {}. Context: {}",
        command_name, static_cast<int>(node.data_type), key_context);
    return std::nullopt;
}
```

='='=' File: ./UserService/infrastructure/state_storage/redis_dao/redis_client.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <string>
#include <boost/redis/connection.hpp>
#include <boost/asio.hpp>

namespace user_service::infrastructure {
    struct RedisConfig {
        std::string host;
        std::string port;
    };
    class RedisClient {
    public:
        RedisClient(const std::shared_ptr<boost::asio::io_context>& ioc, const RedisConfig& config);
        ~RedisClient();
        boost::asio::awaitable<void> Init();
        boost::asio::awaitable<void> Set(const std::string& key, const std::string& value);
        boost::asio::awaitable<void> Set(const std::string& key, const std::string& value, const std::chrono::seconds& expiry);
        boost::asio::awaitable<std::optional<std::string>> Get(const std::string& key);
    private:
        // ç­‰å¾…è”é€š
        boost::asio::awaitable<void> Ping();
        // ç»“æœè§£æ
        [[nodiscard]] std::optional<std::string> ExtractResult(const boost::system::result<boost::redis::resp3::node, boost::redis::adapter::error>& result,
            const std::string& command_name, const std::string& key_context= "") const;

        const std::shared_ptr<boost::asio::io_context> ioc_;
        std::shared_ptr<boost::redis::connection> conn_;
        boost::redis::config cfg_;
    };
}
```

='='=' File: ./UserService/infrastructure/persistence/postgresql/src/pq_connection.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/pq_connection.h"
#include <spdlog/spdlog.h>

using namespace user_service::infrastructure;

PQConnection::PQConnection(boost::asio::io_context &ioc) : conn_(nullptr, &PQfinish), socket_(ioc) {
}

boost::asio::awaitable<void> PQConnection::AsyncConnect(const std::string &conn_str) {
    // å¼‚æ­¥å¯åŠ¨è¿æ¥
    conn_.reset(PQconnectStart(conn_str.c_str()));
    if (!conn_ || PQstatus(conn_.get()) == CONNECTION_BAD) {
        throw std::runtime_error(std::string("Connection failed: ") + PQerrorMessage(conn_.get()));
    }
    // è·å–æ•°æ®åº“åº•å±‚æè¿°ç¬¦ï¼Œå¹¶äº¤ç»™ boost åç¨‹ç›‘å¬
    socket_.assign(PQsocket(conn_.get()));

    // è½®è¯¢è¿æ¥çŠ¶æ€ç›´åˆ°æˆåŠŸï¼Œwhileè´Ÿè´£æ¨è¿›å‰é¢çš„
    while (true) {
        // è·å–å½“å‰æ•°æ®åº“çŠ¶æ€ï¼ŒåŒæ—¶ä¹Ÿè´Ÿè´£é©±åŠ¨è¯»å†™æ“ä½œ
        const auto poll_status = PQconnectPoll(conn_.get());
        if (poll_status == PGRES_POLLING_WRITING) {
            // param1: ç­‰å¾…å¯ä»¥å†™æ“ä½œï¼Œ param2: ä»¥åç¨‹çš„æ–¹å¼
            co_await socket_.async_wait(boost::asio::posix::stream_descriptor::wait_write, boost::asio::use_awaitable);
        } else if (poll_status == PGRES_POLLING_READING) {
            co_await socket_.async_wait(boost::asio::posix::stream_descriptor::wait_read, boost::asio::use_awaitable);
        } else if (poll_status == PGRES_POLLING_OK) {
            SPDLOG_DEBUG("Connected to Postgresql successfully!");
            co_return; // è¿æ¥æˆåŠŸ
        } else {
            throw std::runtime_error(std::string("Async connection failed: ") + PQerrorMessage(conn_.get()));
        }
    }
}

boost::asio::awaitable<PGResultPtr> PQConnection::AsyncExecParams(const std::string &query,
                                                                    const std::vector<std::string> &params) {
    // ç»´æŠ¤å‚æ•°åˆ—è¡¨
    std::vector<const char *> param_values;
    param_values.reserve(params.size());
    for (const auto &p: params) {
        param_values.push_back(p.c_str());
    }
    // éé˜»å¡æŸ¥è¯¢
    if (PQsendQueryParams(conn_.get(), query.c_str(), params.size(), nullptr,
                          param_values.data(), nullptr, nullptr, 0) == 0) {
        throw std::runtime_error(std::string("Failed to send query: ") + PQerrorMessage(conn_.get()));
    }
    while (true) {
        // ä»¥åç¨‹æ–¹å¼ç›‘å¬æ•°æ®åº“ç»™å‡ºçš„åé¦ˆ
        co_await socket_.async_wait(boost::asio::posix::stream_descriptor::wait_read, boost::asio::use_awaitable);
        // çœŸæ­£è¯»å–æ•°æ®ï¼ŒæˆåŠŸåˆ™ä¸º 1ï¼Œå¤±è´¥åˆ™ä¸º 0
        if (PQconsumeInput(conn_.get()) == 0) {
            throw std::runtime_error(std::string("Failed to consume input: ") + PQerrorMessage(conn_.get()));
        }
        // å½“å‰PQè¿æ¥ä¸å¿™ä»£è¡¨æ•°æ®æ¥å—å®Œæ•´ï¼ˆå¯ä»¥å®‰å…¨çš„ç”¨ PQgetResult æ¥å—ç»“æœäº†ï¼‰
        if (PQisBusy(conn_.get()) == 0) {
            break;
        }
    }

    // å¤„ç†è¿”å›ç»“æœ
    PGResultPtr result(nullptr, &PQclear);
    while (true) {
        // æŠŠç»“æœä» pqçš„æ•°æ®ç»“æ„ ä¸­æ‹·è´å‡ºæ¥
        result.reset(PQgetResult(conn_.get()));
        // æœ‰äº›æ“ä½œå¯èƒ½æœ‰å¤šä¸ªè¿”å›ç»“æœï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨ whileå¾ªç¯ é…åˆ result æ£€æŸ¥
        if (!result) {
            // å¦‚æœç»“æœä¸ºç©ºæŒ‡é’ˆï¼Œè¡¨ç¤ºæ‰€æœ‰ç»“æœéƒ½å·²å¤„ç†å®Œæ¯•
            break;
        }
        ExecStatusType status = PQresultStatus(result.get());
        // æ£€æŸ¥ sqlè¿è¡Œ æ˜¯å¦é”™è¯¯
        if (status == PGRES_BAD_RESPONSE || status == PGRES_FATAL_ERROR) {
            // æ‹¿åˆ°é”™è¯¯ä¿¡æ¯å¹¶æŠ›å‡ºå¼‚å¸¸
            throw std::runtime_error(std::string("SQL Error: ") + PQresultErrorMessage(result.get()));
        }
        // PGRES_TUPLES_OK ä»£è¡¨æ‰§è¡ŒæˆåŠŸå¹¶è¿”å›äº†æˆåŠŸçš„ç»“æœï¼Œæ¯”å¦‚: select
        // PGRES_COMMAND_OK ä»£è¡¨æ‰§è¡Œè¯­å¥æ‰§è¡ŒæˆåŠŸï¼ˆæ²¡æœ‰è¿”å›ç»“æœçš„é‚£ç§è¯­å¥ï¼‰ï¼Œæ¯”å¦‚: updateã€insert
        if (status == PGRES_TUPLES_OK || status == PGRES_COMMAND_OK) {
            co_return result; // æˆåŠŸï¼Œè¿”å›ç»“æœ
        }
    }
    // å¾ªç¯ç»“æŸè¿˜æ²¡æœ‰è¿”å›ï¼Œå¾ˆå¯èƒ½æ˜¯å‡ºé”™äº†æˆ–æ²¡æœ‰è¿”å›ç»“æœé›†
    co_return PGResultPtr(nullptr, &PQclear);
}

```

='='=' File: ./UserService/infrastructure/persistence/postgresql/src/async_connection_pool.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/async_connection_pool.h"

using namespace user_service::infrastructure;


AsyncConnectionPool::AsyncConnectionPool(const std::shared_ptr<boost::asio::io_context>& ioc, const DbPoolConfig& db_pool_config)
    : ioc_(ioc),
      conn_str_(db_pool_config.conn_str),
      pool_size_(db_pool_config.pool_size),
      signal_channel_(*ioc, (std::numeric_limits<std::size_t>::max)()) {
    SPDLOG_DEBUG("Execute AsyncConnectionPool Constructor");
    if (pool_size_ <= 0) {
        throw std::invalid_argument("Pool size must be positive.");
    }
}

boost::asio::awaitable<void> AsyncConnectionPool::Init() {
    spdlog::info("Initializing connection pool with size {}...", pool_size_);
    for (int i = 0; i < pool_size_; ++i) {
        auto conn = std::make_shared<PQConnection>(*ioc_);
        co_await conn->AsyncConnect(conn_str_);
        {
            std::lock_guard lock(mutex_);
            pool_.push_back(conn);
        }
    }
    spdlog::info("Connection pool initialized successfully.");
}

boost::asio::awaitable<PooledConnection> AsyncConnectionPool::GetConnection() {
    std::unique_lock lock(mutex_);
    while (pool_.empty()) {
        lock.unlock();
        // co_await waiter_.async_wait(boost::asio::use_awaitable);
        (void) co_await signal_channel_.async_receive(boost::asio::use_awaitable);
        lock.lock();
    }
    const std::shared_ptr<PQConnection> conn_sh_ptr = pool_.front();
    pool_.pop_front();
    co_return PooledConnection(conn_sh_ptr.get(), ConnectionReleaser(conn_sh_ptr, shared_from_this()));
}

void AsyncConnectionPool::ReturnConnection(const std::shared_ptr<PQConnection>& conn_sh_ptr) {
    {
        // æ²¡æœ‰è§£é”æ“ä½œï¼Œçº¯é RAIIï¼Œä½†unique_lockå¯ä»¥è‡ªå·±è§£é”
        std::lock_guard lock(mutex_);
        pool_.push_back(conn_sh_ptr);
    }
    // æ¡ä»¶å˜é‡å”¤é†’
    // waiter_.cancel_one();
    // å‘ä¿¡å·å”¤é†’
    signal_channel_.try_send(boost::system::error_code{});

}

// å®ç° Deleter
inline void ConnectionReleaser::operator()(PQConnection *conn) const {
    // weak_ptr è‹¥è§‚å¯Ÿå¯¹è±¡ä¸å­˜åœ¨ä¼šè¿”å› shared_ptr åŒ…è£¹ä¸€ä¸ªnullptr
    if (auto pool_sh_ptr = pool.lock()) {
        pool_sh_ptr->ReturnConnection(conn_sh_ptr);
    } else {
        // å¦‚æœè¿æ¥æ± å·²ç»è¢«é”€æ¯ï¼Œå°±è®© PQConnection çš„ shared_ptr è‡ªåŠ¨ç®¡ç†å†…å­˜
        spdlog::warn("Connection pool gone. Connection will be closed.");
    }
}

```

='='=' File: ./UserService/infrastructure/persistence/postgresql/include/pq_connection.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <libpq-fe.h>
#include <boost/asio.hpp>
#include <string>
#include <vector>
#include <memory>

namespace user_service::infrastructure {
    using PGResultPtr = std::unique_ptr<PGresult, decltype(&PQclear)>;

    class PQConnection : public std::enable_shared_from_this<PQConnection> {
    public:
        explicit PQConnection(boost::asio::io_context &ioc);

        boost::asio::awaitable<void> AsyncConnect(const std::string &conn_str);

        boost::asio::awaitable<PGResultPtr> AsyncExecParams(const std::string &query,
                                                              const std::vector<std::string> &params);

    private:
        // ç»´æŠ¤æ•°æ®åº“è¿æ¥ï¼Œ
        std::unique_ptr<PGconn, decltype(&PQfinish)> conn_;
        // boostæä¾›çš„æè¿°ç¬¦ç®¡ç†å™¨
        boost::asio::posix::stream_descriptor socket_;
    };
}

```

='='=' File: ./UserService/infrastructure/persistence/postgresql/include/async_connection_pool.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "pq_connection.h"
#include <deque>
#include <mutex>
#include <memory>
#include <boost/asio/experimental/channel.hpp>
#include <spdlog/spdlog.h>

namespace user_service::infrastructure {
    // é…ç½®æ–‡ä»¶
    struct DbPoolConfig {
        std::string conn_str;
        int pool_size;
    };
    class AsyncConnectionPool;
    // Deleter çš„å·¥ä½œä¸æ˜¯ delete è¿æ¥ï¼Œè€Œæ˜¯å°†å…¶å½’è¿˜ç»™è¿æ¥æ± 
    struct ConnectionReleaser {
        explicit ConnectionReleaser(const std::shared_ptr<PQConnection> &conn,
                                    const std::shared_ptr<AsyncConnectionPool> &p) : conn_sh_ptr(conn), pool(p) {
        }
        // å®ç°æ”¾åé¢ï¼Œå› ä¸ºå®ƒéœ€è¦å®Œæ•´çš„ Pool å®šä¹‰ï¼Œå‚æ•°éœ€è¦ä¸€å®šä¿è¯æ˜¯ç½—æŒ‡é’ˆè£¸æŒ‡é’ˆ
        void operator()(PQConnection *conn) const;
        // æŒæœ‰ PQConnectionçš„shared_ptr ä¿è¯ä¸è¢«è‡ªåŠ¨é”€æ¯
        std::shared_ptr<PQConnection> conn_sh_ptr;
        // ä½¿ç”¨ weak_ptr é˜²æ­¢å¾ªç¯å¼•ç”¨ï¼Œå¹¶ä¸”æ˜¯çº¿ç¨‹å®‰å…¨çš„
        std::weak_ptr<AsyncConnectionPool> pool;
    };

    // å°è£…æ± åŒ–æ•°æ®åº“è¿æ¥ï¼Œå¹¶æ·»åŠ  deleter
    using PooledConnection = std::unique_ptr<PQConnection, ConnectionReleaser>;

    class AsyncConnectionPool : public std::enable_shared_from_this<AsyncConnectionPool> {
    public:
        AsyncConnectionPool(const std::shared_ptr<boost::asio::io_context>& ioc, const DbPoolConfig& db_pool_config);

        boost::asio::awaitable<void> Init();

        boost::asio::awaitable<PooledConnection> GetConnection();

    private:
        friend struct ConnectionReleaser;

        void ReturnConnection(const std::shared_ptr<PQConnection>& conn_sh_ptr);

        const std::shared_ptr<boost::asio::io_context> ioc_;
        const std::string conn_str_;
        const int pool_size_;
        std::mutex mutex_;
        // æ³¨æ„ PQConnection ä¸å¯å¤åˆ¶
        std::deque<std::shared_ptr<PQConnection> > pool_;
        /* åŸè®¡åˆ’ä½¿ç”¨steady_timerä½œä¸ºæ¡ä»¶å˜é‡ï¼Œä½†æ˜¯åœ¨è·å–è¿æ¥éƒ¨åˆ†ï¼Œ
         * unlockåå’Œåç¨‹æŒ‚èµ·å‰çš„ç¼éš™ï¼Œå¦‚æœå‘ç”Ÿäº†notify_oneæ“ä½œä¼šå¯¼è‡´è¿™ä¸ªå”¤é†’ä¸¢å¤±ï¼Œ
         * æ‰€ä»¥è¿™ä¸ªä½ç½®éœ€è¦ä¸€ä¸ªåŸå­æ“ä½œæ¥å®ç°unlockå’Œåç¨‹æŒ‚èµ·ï¼ŒæŒ‰ç…§stdz
         */
        // boost::asio::steady_timer waiter_;
        boost::asio::experimental::channel<void(boost::system::error_code)> signal_channel_;
    };
}

```

='='=' File: ./UserService/infrastructure/persistence/dao/user_dao.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "infrastructure/persistence/dao/user_dao.h"
#include <spdlog/spdlog.h>

using namespace user_service::infrastructure;
using namespace user_service::domain;

UserDao::UserDao(const std::shared_ptr<AsyncConnectionPool>& pool): pool_(pool) {

}

UserDao::~UserDao() = default;

boost::asio::awaitable<std::optional<User>> UserDao::GetUserByPhoneNumber(const std::string& phone_number)
{

}
```

='='=' File: ./UserService/infrastructure/persistence/dao/user_dao.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <optional>

#include "domain/user.h"
#include "infrastructure/persistence/postgresql/include/async_connection_pool.h"

namespace user_service::infrastructure
{
    class UserDao
    {
    public:
        explicit UserDao(const std::shared_ptr<AsyncConnectionPool>& pool);
        ~UserDao();
        boost::asio::awaitable<std::optional<domain::User>> GetUserByPhoneNumber(const std::string& phone_number);
    private:
        const std::shared_ptr<AsyncConnectionPool> pool_;
    };
}
```

='='=' File: ./UserService/utils/interface/i_verification_code_generator.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include <string>

namespace user_service::util {
    class IVerificationCodeGenerator {
    public:
        virtual ~IVerificationCodeGenerator() = default;
        virtual std::string Generate(int length) = 0;
    };
}
```

='='=' File: ./UserService/utils/src/verification_code_generator.cc '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#include "../include/verification_code_generator.h"

using namespace user_service::util;

CodeGenerator::~CodeGenerator() = default;

std::string CodeGenerator::Generate(int length) {
    std::uniform_int_distribution<int> distribution(0, 9);

    std::string code;
    code.reserve(length);

    for (int i = 0; i < length; ++i) {
        // è·å–å½“å‰çº¿ç¨‹çš„å¼•æ“ (æ— é”)
        std::mt19937& engine = GetThreadLocalEngine();
        // ç”Ÿæˆä¸€ä¸ªæ•°å­— (0-9)
        int digit = distribution(engine);
        code.push_back(digit + '0');
    }

    return code;
}

std::mt19937& CodeGenerator::GetThreadLocalEngine() {
    static thread_local std::mt19937 engine(std::random_device{}());
    return engine;
}
```

='='=' File: ./UserService/utils/include/verification_code_generator.h '='='='
```
// Copyright (c) 2025 seaStarLxy.
// Licensed under the MIT License.

#pragma once
#include "utils/interface/i_verification_code_generator.h"
#include <random>

namespace user_service::util {
    class CodeGenerator final: public IVerificationCodeGenerator{
    public:
        ~CodeGenerator() override;
        std::string Generate(int length) override;
    private:
        static std::mt19937& GetThreadLocalEngine();
    };
}

```

='='=' File: ./apiGateway/README.md '='='='
```


```shell
# å‰å°è¿è¡Œ envoy
envoy -c /home/seastar/ECommerceSystem-Microservices/apiGateway/envoy.yaml -l info
```

```shell
# ç”Ÿæˆ proto.pb
/home/seastar/ECommerceSystem-Microservices/UserService/cmake-build-debug/vcpkg_installed/x64-linux/tools/protobuf/protoc \
  -I /home/seastar/ECommerceSystem-Microservices/IDL \
  -I /home/seastar/ECommerceSystem-Microservices/third_party/googleapis \
  --include_imports \
  --descriptor_set_out=/home/seastar/ECommerceSystem-Microservices/apiGateway/proto.pb \
  /home/seastar/ECommerceSystem-Microservices/IDL/UserService/v1/user_service.proto
  

```
```

='='=' File: ./apiGateway/envoy.yaml '='='='
```
static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8080 # Envoy å¯¹å¤–ç›‘å¬çš„ HTTP/JSON ç«¯å£
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: ingress_http
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: local_service
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            # è·¯ç”±åˆ° user_service_cluster
                            cluster: user_service_cluster
                            timeout: 60s
                http_filters:
                  # gRPC-JSON è½¬ç å™¨
                  - name: envoy.filters.http.grpc_json_transcoder
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder

                      # --------------------------------------------------
                      # æŒ‡å®šçš„ proto.pb æ–‡ä»¶è·¯å¾„
                      proto_descriptor: "/home/ubuntu/ECommerceSystem-Microservices/apiGateway/proto.pb"
                      # --------------------------------------------------

                      services: ["user_service.proto.v1.UserService", "user_service.proto.v1.AuthService"]
                      print_options:
                        add_whitespace: true
                        always_print_primitive_fields: true
                        always_print_enums_as_ints: false
                        preserve_proto_field_names: true

                  # è·¯ç”±å™¨è¿‡æ»¤å™¨ï¼Œå¿…é¡»åœ¨æœ€å
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    - name: user_service_cluster
      connect_timeout: 5s
      type: STRICT_DNS
      # gRPC æœåŠ¡å¿…é¡»ä½¿ç”¨ http2
      typed_extension_protocol_options:
        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
          "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
          explicit_http_config:
            http2_protocol_options: {}
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: user_service_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      # æŒ‡å‘æœ¬åœ°è¿è¡Œçš„ gRPC æœåŠ¡
                      address: "127.0.0.1"
                      # gRPC æœåŠ¡çš„ç«¯å£
                      port_value: 50051
```

='='=' File: ./.github/workflows/ci.yml '='='='
```
name: C++ gRPC CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  VCPKG_ROOT: ${{ github.workspace }}/vcpkg
  BUILD_DIR: ${{ github.workspace }}/UserService/build

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    steps:
      - name: 1. Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: 2. Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            ninja-build \
            zip \
            unzip \
            tar \
            libssl-dev \
            curl \
            gdb \
            bison \
            flex \
            autoconf \
            automake \
            libtool \
            git

      - name: 2.1 Clone vcpkg
        run: |
          git clone https://github.com/microsoft/vcpkg.git ${{ env.VCPKG_ROOT }}

      - name: 2.2 Bootstrap vcpkg
        run: ${{ env.VCPKG_ROOT }}/bootstrap-vcpkg.sh

      - name: 2.3 Setup vcpkg binary cache
        uses: actions/cache@v4
        with:
          # vcpkg åœ¨ Linux runner ä¸Šçš„é»˜è®¤äºŒè¿›åˆ¶ç¼“å­˜è·¯å¾„
          path: ~/.cache/vcpkg
          # å½“ vcpkg.json æ–‡ä»¶å†…å®¹æ”¹å˜æ—¶ï¼Œç¼“å­˜çš„ key æ”¹å˜
          key: vcpkg-binary-cache-${{ runner.os }}-${{ hashFiles('**/vcpkg.json') }}
          # Fallback key
          restore-keys: |
            vcpkg-binary-cache-${{ runner.os }}-

      - name: 3. Configure CMake
        run: |
          cmake -B $BUILD_DIR \
                -S $GITHUB_WORKSPACE/UserService \
                -G Ninja \
                -DCMAKE_BUILD_TYPE=Debug \
                -DCMAKE_MAKE_PROGRAM=/usr/bin/ninja \
                -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake

      - name: 4. Build project
        run: |
          cmake --build $BUILD_DIR --target UserServiceServer

      - name: 5. Run Program (å†’çƒŸæµ‹è¯•)
        run: |
          echo "Attempting to start the server..."
          EXECUTABLE_PATH="$BUILD_DIR/UserServiceServer"
          
          cd "$BUILD_DIR"
          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
          if [ ! -f "$EXECUTABLE_PATH" ]; then
            echo "Error: Executable not found at $EXECUTABLE_PATH"
            ls -R $BUILD_DIR
            exit 1
          fi

          # 1. åå°è¿è¡Œ
          $EXECUTABLE_PATH &
          
          # 2. æ‹¿åˆ°è¿™ä¸ªåå°è¿›ç¨‹çš„ PID
          SERVER_PID=$!
          echo "Server started with PID ${SERVER_PID}"

          # 3. ç­‰å¾… 10 ç§’
          echo "Waiting 10 seconds for smoke test..."
          sleep 10

          # 4. æ£€æŸ¥æœåŠ¡å™¨è¿›ç¨‹æ˜¯å¦è¿˜æ´»ç€
          if kill -0 $SERVER_PID; then
            echo "SMOKE TEST SUCCESS: Server is still running after 10 seconds."
            # 5. æ€æ­»æœåŠ¡ï¼Œè®© CI æ­¥éª¤å¯ä»¥æ­£å¸¸ç»“æŸ
            kill $SERVER_PID
          else
            echo "SMOKE TEST FAILED: Server crashed within 10 seconds!"
            exit 1 # é€€å‡ºç é 0ï¼Œæ ‡è®° CI å¤±è´¥
          fi
```

